1. 지문 읽기 및 컴퓨터적 사고
2. 복잡도 분석
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

핵심 아이디어를 캐치한다면, 간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제한다!


# 자료형

## 정수형

양의 정수, 음의 정수, 0

```python
# 양의 정수
a = 1000
print(a) # 1000

# 음의 정수
a = -7
print(a) # -7

# 0
a = 0
print(a) # 0
```

## 실수형

소수점 아래의 데이터를 포함하는 수 자료형

```py
# 양의 실수
a = 157.93

# 음의 실수
a = -187.2

# 소수부가 0일 때 0 생략
a = 5.

# 정수부가 0일 때 0 생략
a = -.7
```

## 지수 표현 방식

e나 E 다음에 오는 수는 10의 지수부를 의미하며 실수형으로 처리된다.
예를 들어 1e9라고 입력하게 되면 10의 9제곱이 된다.
임의의 큰 수를 표현하기 위해 자주 사용된다.
최단 경로 알고리즘에서 도달할 수 없는 노드에 대하여 최단 거리를 무한 (INF) 로 설정한다.

```py
# 1,000,000,000
a = 1e9

# 752.5
a = 75.25e1

# 3.954
a = 3954e-3
```

# 수 자료형의 연산

- 사칙연산과 나머지 연산자가 많이 사용
- 파이썬에서 나누기 연산자 (/) 는 나눠진 결과를 실수형으로 반환한다.
- 나머지 연산자 (%)
- 몫 연산자 (//)
- 거듭 제곱 연산자 (**)


# 리스트 자료형

- 여러 개의 데이터를 연속적으로 담아 처리하기 위해 사용하는 자료형
- 배열의 기능 및 연결 리스트와 유사한 기능 지원
- 배열 혹은 테이블


## 리스트 초기화

- 대괄호 ([]) 안에 원소를 넣어 초기화하며 쉼표(,)로 원소를 구분
- 비어있는 리스트 선언할 때는 list() 혹은 [] 사용

```py
a = [1,2,3,4,5,6,7,8,9]

print(a[3]) # 4

n = 10
a = [0] * n
print(a) # [0,0,0,0,0,0,0,0,0,0]
```

## 리스트의 인덱싱과 슬라이싱

리스트의 특정한 원소에 접근하는 것을 인덱싱이라고 한다.
파이썬의 인덱스 값은 양의 정수, 음의 정수 모두 사용할 수 있으며 음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.

연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 이용한다.
대괄호 안에 콜론을 넣어서 시작 인덱스와 끝 인덱스를 설정한다.
끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다.

```py
a = [1,2,3,4,5,6,7,8,9]

print(a[3]) # 4
print(a[1:4]) # [2,3,4]
```

## 리스트 컴프리헨션

리스트를 초기화하는 방법 중 하나.
대괄호 안에 조건문과 반복문을 적용하여 리스트를 초기화 할 수 있다.

```py
array = [i for i in range(10)]

print(array) # [0,1,2,3,4,5,6,7,8,9]

# 0부터 19까지의 수 중 홀수만 포함하는 리스트
array = [i for i in range(20) if i % 2 == 1]

# 1부터 9까지의 수들의 제곱 값을 포함하는 리스트
array = [i * i for i in range(1, 10)]
```

- 리스트 컴프리헨션은 2차원 리스트를 초기화할 때 효과적으로 사용될 수 있다.
- 특히 N X M 크기의 2차원 리스트를 한 번에 초기화해야 할 때 유용하다.
- 좋은 예 : array = [[0] * m for _ in range(n)]
- 잘못된 예 : array = [[0] * m] * n
- 다음과 같이 작성하면 예기치 않은 결과가 나올 수 있다.
- 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식된다.

> **언더바?** 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 언더바를 자주 사용한다.

## 리스트 관련 메서드

- append() : 리스트에 원소를 하나 삽입할 때, O(1)
- sort() : 오름차순으로 정렬, O(NlogN)
- sort(reverse = True) : 내림차순 정렬, O(NlogN)
- reverse() : 리스트의 원소를 모두 뒤집음, O(N)
- insert(삽입할 위치 인덱스, 삽입할 값) : O(N)
- count() : 데이터 개수를 셀 때, O(N)
- remove() : 특정한 값을 갖는 원소를 제거하는데 값을 가진 원소가 여러개일 경우 하나만 제거, O(N)


# 문자열 자료형

문자열 변수를 초기화 할 때는 큰따옴표나 작은 따옴표를 이용한다.

전체 문자열을 큰따옴표로 구성하는 경우, 내부적으로 작은 따옴표를 포함 할 수 있다.
전체 문자열을 작은 따옴표로 구성하는 경우, 내부적으로 큰 따옴표를 포함할 수 있다.
혹은 백슬래시(\)를 사용하면, 큰따옴표나 작은따옴표를 원하는 만큼 포함시킬 수 있다.

## 문자열 연산

- 덧셈을 이용하면 문자열이 더해져서 연결된다.
- 문자열 변수를 특정한 양의 정수와 곱하는 경우 문자열이 그 값만큼 여러번 더해진다.
- 문자열에 대해서도 인덱싱과 슬라이싱을 이용할 수 있다. but, 문자열은 특정 인덱스의 값을 변경할 수 없다. 

# 튜플 자료형

리스트와 유사하지만 차이가 있다.
튜플은 한 번 선언된 값을 변경할 수 없다. 리스트는 대괄호를 이용하지만 튜플은 소괄호를 이용한다.
튜플은 리스트에 비해 상대적으로 공간 효율적이다.

```py
a = (1,2,3,4,5,6,7,8,9)

# 네번째 원소만 출력
print(a[3]) # 4

# 두번째 원소부터 네번째 원소까지
print(a[1 : 4]) # (2,3,4)
```

## 튜플을 사용하면 좋은 경우

- 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
    - 최단 경로 알고리즘에서는 (비용, 노드번호)의 형태로 튜플 자료형을 자주 사용한다.
- 데이터의 나열을 해싱의 키 값으로 사용해야 할 때
    - 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용될 수 있다.
- 리스트보다 메모리를 효율적으로 사용해야 할 때


# 사전 자료형

키(key)와 값(value)의 쌍을 데이터로 가지는 자료형으로 변경 불가능한 자료형을 키로 사용할 수 있다.
파이썬의 사전 자료형은 해시 테이블을 이용하므로 데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

```PY
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data) # {'사과' : 'Apple', '바나나' : 'Banana', '코코넛' : 'Coconut'}
```

## 사전 자료형 관련 메서드

- keys() : 키 데이터만 뽑아서 리스트로 이용할 때
- values() : 값 데이터만 뽑아서 리스트로 이용할 때


# 집합 자료형

중복 허용X, 순서X 
데이터가 존재하는지 존재하지 않는지 여부를 표현할 수 있다.

집합은 리스트 혹은 문자열을 이용해서 초기화할 수 있다. set() 함수 이용
혹은 중괄호({}) 안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있다.

데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

```PY
data = set([1,1,2,3,4,4,5])
print(data) # {1,2,3,4,5}

data = {1,1,2,3,4,4,5}
print(data) # {1,2,3,4,5}

a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

# 합집합
print(a | b) # {1,2,3,4,5,6,7}
# 교집합
print(a & b) # {3,4,5}
# 차집합
print(a - b) # {1,2}
```


# 기본 입출력

input() : 한 줄의 문자열을 입력 받는 함수

map() : 리스트의 모든 원소에 각각 특정한 함수를 적용할 때 사용

- 공백을 기준으로 구분된 데이터를 입력받을 때 => **list(map(int, input().split()))**
- 공백을 기준으로 구분된 데이터의 개수가 정해져있는 경우 => a, b, c = map(int, input().split())

```py
n = int(input())
data = list(map(int, input().split()))

print(n) # 5
print(data) # [78, 95, 48, 15, 75]
```

## 빠르게 입력 받기

사용자로부터 입력을 최대한 빠르게 받아야 하는 경우
sys.stdin.readline() 메서드 이용
단, 입력 후 줄바꿈 기호가 입력되므로 rstrip() 메서드를 함께 사용

## 자주 사용되는 표준 출력 방법

파이썬에서 기본 출력은 print() 함수를 이용한다. 각 변수를 콤마를 사용하여 띄어쓰기로 구분하여 출력할 수 있다.

print()는 기본적으로 출력 이후에 줄 바꿈을 수행한다. 줄바꿈을 원치 않는 경우 end 속성을 이용할 수 있다.

```py
a = 1
b = 2
print(a, b)
print(7, end=" ")
print(8, end=" ")

answer = 7
print("정답은 " + str(answer) + "입니다.")

# 1 2
# 7 8 정답은 7입니다.
```

## f-string 

문자열 앞에 접두사 f를 붙여 사용
간단하게 변수명과 문자열, 정수를 함께 넣을 수 있다.

```py
answer = 7
print(f"정답은 {answer}입니다.")
```


# 조건문

코드의 블록을 **들여쓰기**로 지정한다. (공백문자 4개)
if ~ elif ~ else

```py
a = 5

if a >= 0:
    print("a >= 0")
elif a >= -10:
    print("0 > a >= -10")
else:
    print("-10 > a")

# a >= 0
```

## 기타 연산자

in 연산자, not in 연산자

x in 리스트 => 리스트 안에 x가 들어가 있을 때 True이다.
x not in 문자열 => 문자열 안에 x가 들어가 있지 않을 때 True이다.

## pass 키워드

아무것도 처리하고 싶지 않을 때 pass 키워드를 사용한다.

디버깅 과정에서 일단 조건문의 형태만 만들어 놓고 조건문을 처리하는 부분은 비워놓고 싶은 경우

```py
score = 85

if score >= 80:
    pass 
else:
    print("성적이 80점 미만입니다")

print("프로그램 종료")

# 프로그램 종료
```

## 조건문 간소화

실행될 소스코드가 한 줄인 경우,
조건부 표현식은 if~else문을 한 줄에 작성할 수 있도록 해줌. (if문이 가운데)

```py
score = 85

if score >= 80: result = "Success"
else: result = "Fail"

result = "Success" if score >= 80 else "Fail"
```

# 반복문

while문보다 for문 사용하는게 코드가 짧아지는 경우가 많다.

```py
i = 1
result = 0

while i <= 9:
    result += i
    i += 1

print(result) # 45
```

```py
i = 1
result = 0

while i <= 9:
    if i % 2 == 1:
        result += i
    i += 1

print(result) # 25
```

## for문

for 변수 in 리스트
in 뒤에 오는 데이터에 포함되어 있는 원소를 첫번째 인덱스부터 차례대로 하나씩 방문한다.

```py
array = [9,8,7,6,5]

for x in array:
    print(x)

# 9 8 7 6 5
```

for문에서 연속적인 값을 차례대로 순회할 때는 range()를 주로 사용한다.
**range(시작 값, 끝 값 + 1)** 형태
인자를 하나만 넣으면 자동으로 시작값은 0이 된다.

```py
result = 0

# 1~9까지 순회
for i in range(1, 10):
    result =+ i

print(result)

# 45
```

## continue 키워드

남은 코드의 실행을 건너뛰고 다음 반복을 진행하고자 할 때 사용

```py
result = 0

for i in range(1, 10):
    if i % 2 == 0:
        continue
    result += i

print(result) # 25
```

## break 키워드

반복문을 즉시 탈출하고자 할 때

```py
# 1부터 5까지 정수를 차례대로 출력할 때

i = 1

while True:
    print("현재 i의 값:", i)
    if i == 5:
        break
    i += 1
```

## 반복문 예시

```py
scores = [90, 85, 77, 65, 97]
cheating_student_list = {2, 4}

for i in range(5):
    if i + 1 in cheating_student_list:
        continue
    if scores[i] >= 80:
        print(i + 1, "번 학생은 합격입니다.")

# 1번 학생은 합격입니다.
# 5번 학생은 합격입니다.
```

# 파이썬의 함수

내장 함수 : 파이썬이 기본적으로 제공하는 함수
사용자 정의 함수 : 개발자가 직접 정의하여 사용할 수 있는 함수

## 함수 정의하기

함수를 사용하면 소스코드의 길이를 줄일 수 있다.
매개변수 : 함수 내부에서 사용할 변수
반환 값 : 함수에서 처리된 결과를 반환

```py
def 함수명(매개변수):
    실행할 소스코드
    return 반환 값
```

```py
def add(a, b):
    return a + b

print(add(3, 7)) # 10

def add2(a, b):
    print('함수의 결과: ', a + b)

add(3, 7) # 함수의 결과: 10
```

파라미터의 변수를 직접 지정할 수 있다. 순서 상관없음

```py
def add(a, b):
    print('함수의 결과: ', a + b)

add(b = 3, a = 7) # 함수의 결과: 10
```

## global 키워드

global 키워드로 변수를 지정하면 해당 함수에서는 지역 변수를 만들지 않고, 함수 바깥에 선언된 변수를 바로 참조하게 된다.

```py
a = 10

def func():
    global a
    a += 1
    print(a)

func() # 11
```

## 람다 표현식

람다 표현식을 이용하면 특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다는 점이 특징이다.

```py
def add(a, b):
    return a + b

# 일반적인 add() 메서드 사용
print(add(3, 7))

# 람다 표현식으로 구현
print((lambda a, b: a + b)(3, 7)) # 10
```

```py
array = [('홍길동', 50), ('이순신', 32), ('아무개', 74)]

def my_key(x):
    return x[1]

print(sorted(array, key=my_key))
print(sorted(array, key=lambda x: x[1]))

# [('이순신', 32), ('홍길동', 50), ('아무개', 74)]

list1 = [1,2,3,4,5]
list2 = [6,7,8,9,10]

result = map(lambda a, b: a + b, list1, list2)

print(list(result))

# [7,9,11,13,15]
```

# 실전에서 유용한 표준 라이브러리

1. itertools

    - 파이썬에서 반복되는 형태의 데이터를 처리하기 위한 유용한 기능들을 제공
    - 특히, 순열과 조합 라이브러리가 자주 사용됨

2. heapq

    - 힙 자료구조를 제공
    - 일반적으로 우선순위 큐 기능을 구현하기 위해 사용됨 (최단 경로 알고리즘)

3. bisect

    - 이진 탐색 기능을 제공

4. collections

    - 덱, 카운터 등의 유용한 자료구조를 포함함

5. math

    - 필수적인 수학적 기능 제공
    - 팩토리얼, 제곱근, 최대공약수, 삼각함수 관련 함수부터 파이와 같은 상수를 포함


```py
result = sum([1,2,3,4,5])
print(result) # 15

min(7,3,5,2)
min(7,3,5,2)

eval("(3+5)*7")

sorted([9,1,8,5,4]) # 오름차순
sorted([9,1,8,5,4], reverse=True) # 내림차순

sorted(array, key=lambda x: x[1], reverse=True)
```

## 순열과 조합

순열 : 서로 다른 n개에서 서로 다른 r개를 선택하여 일렬로 나열하는 것
    {'A', 'B', 'C'}에서 세 개를 선택하여 나열하는 경우 : ABC, ACB, BAC, BCA, CAB, CBA
    nPr = n * (n-1) * (n-2)* ''' * (n-r+1)

조합 : 서로 다른 n개에서 순서와 상관 없이 서로 다른 r개를 선택하는 것
    {'A', 'B', 'C'}에서 순서를 고려하지 않고 두 개를 뽑는 경우 : AB, AC, BC
    nCr = n * (n-1) * (n-2)* ''' * (n-r+1) / r!

```py
# 순열

from itertools import permutations

data = ['A','B','C']

result = list(permutations(data, 3)) # 모든 순열 구하기
print(result) 

# 조합

from itertools import combinations

data = ['A','B','C']

result = list(combinations(data, 2)) # 2개를 뽑는 모든 조합 구하기
print(result)

# 중복 순열
from itertools import product

data = ['A','B','C']

result = list(product(data, repeat=2)) # 2개를 뽑는 모든 순열 구하기 (중복 허용)

# 중복 조합
from itertools import combinations_with_replacement

data = ['A','B','C']

result = list(combinations_with_replacement(data, 2)) # 2개를 뽑는 모든 조합 구하기 (중복 허용)
```

## counter

등장 횟수를 세는 기능 제공
리스트와 같은 반복 가능한 객체가 주어졌을 때 내부의 원소가 몇 번씩 등장했는지 알 수 있다.

```py
from collections import Counter

counter = Counter(['red', 'blue', 'red', 'green', 'blue', 'blue'])

print(counter['blue']) # 3
print(dict(counter)) # {'red': 2, 'blue': 3, 'green': 1}
```

## 최대 공약수와 최소 공배수

최대 공약수를 구할 때는 math 라이브러리의 gcd() 함수를 이용할 수 있다.

```py
import math

# 최소 공배수(lcm) 구하는 함수
def lcm(a, b):
    return a * b // math.gcd(a, b)

print(math.gcd(21, 14)) # 최대 공약수 = 7
print(lcm(21, 14)) # 최소공배수 = 42
```
