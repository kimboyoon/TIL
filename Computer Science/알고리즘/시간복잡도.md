# 시간복잡도 (Time Complexity) 란

특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간

효율적인 알고리즘을 구현한다는 것 == 시간복잡도를 고민한다는 것

## Big-O 표기법

- 알고리즘의 효율성을 표기해주는 표기법
- 시간복잡도를 표기하는 방법 중 가장 자주 사용되는 표기법
- `입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?` 를 표기하는 방법
- **최악의 경우**를 계산하는 방법

### Big-O 표기법의 종류

<img width="600" src="../Images/Big-O.png" alt="BigO">

1. O(1)

- Constant complexity 일정한 복잡도
- 입력 데이터의 크기에 상관없이 **언제나 일정한 시간**이 걸리는 알고리즘
- 예 : 입력 자료의 연산 없이 탐색, 출력, 반환하는 경우


2. O(n)

- Linear complexity 선형 복잡도
- 입력 데이터 값이 증가함에 따라 시간 또는 **같은 비율로 증가**하는 것
- 예 : n번의 반복문을 도는 경우


3. O(logn)

- Logarithmic complexity 로그 복잡도
- 입력 데이터 크기가 커질수록 처리 시간이 로그만큼 짧아지는 알고리즘
- O(1) 다음으로 빠른 시간 복잡도
- 예 : 이진 검색, 퀵 정렬, 병합 정렬, 힙 정렬


4. O(n^2)

- Quadratic complexity 2차 복잡도
- 입력값이 증가함에 따라 처리 시간이 n의 제곱수의 비율로 증가하는 것
- 예 : 이중 for문


5. O(2^n)

- Exponential complexity 기하급수적 복잡도
- Big-O 중 가장 느린 시간 복잡도
- 예 : 피보나치 수열 (1,1,2,3,5)
> 피보나치 수열?
> 다음 항은 바로 앞의 두 항의 합이 되는 수열
> 자기 자신을 다시 호출하는 형태를 띠는 함수인, **재귀함수**의 형태
> 이전의 값들을 중복으로 불러와서 계산하게 되므로 알고리즘의 성능이 안좋다..