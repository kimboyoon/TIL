# 퀵 정렬 Quick Sort

선택, 버블, 삽입 정렬 알고리즘은 모두 O(N^W)의 시간복잡도를 가지는 알고리즘이다. 하지만, 데이터 개수가 커지면 사용하기 어려운 알고리즘이다.

대표적인 빠른 알고리즘인 퀵정렬이다.
퀵정렬은 '분할정복' 알고리즘으로 **평균 속도 O(N * logN)** 를 가진다.

> **특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?**

- 기준 값 : 피벗(Pivot), 가장 앞에 있는 값으로 설정


## 정렬과정

```js
3(p) 7 8 1 5 9 6 10 2 4
// 앞에서부터 3보다 큰 값 = 7
// 뒤에서부터 3보다 작은 값 = 2
// 둘을 바꾼다
3(p) 2 8 1 5 9 6 10 7 4
3(p) 2 1 8 5 9 6 10 7 4
// 3보다 큰 값 = 8, 작은 값 = 1
// 1의 인덱스가 8의 인덱스보다 앞에 있음
// 엇갈렸다
// 이 경우 3과 작은 값을 바꾼다.
1 2 3 8 5 9 6 10 7 4
// 3을 기준으로 분할되었다
// 왼쪽은 3보다 작고 오른쪽은 3보다 큼
1(p) 2 3 8 5 9 6 10 7 4
// 1을 기준으로 분할되었다
// 2도 동일
// 다음은 8이 기준값
1 2 3 8(p) 5 9 6 10 7 4
1 2 3 8(p) 5 4 6 10 7 9
1 2 3 8(p) 5 4 6 7 10 9
1 2 3 7(p) 5 4 6 8 10 9 
1 2 3 6(p) 5 4 7 8 10 9

```

## 코드
```js
function quickSort(arr) {
    if (arr.length <= 1) { // arr가 1개 이하일때
        return arr;
    }

    const pivot = arr[0];
    const left = [];
    const right = [];

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }

    return quickSort(left).concat(pivot, quickSort(right));
}
```

## 시간복잡도

- **O(N * logN)**

1 2 3 4 5 6 7 8 9 10

=> N * N = 10 * 10 = 100

분할하여 실행,

1 2 3 4 5 => 5 * 5 = 25 
6 7 8 9 10 => 5 * 5 = 25

=> 50

- 하지만, 최악의 경우에 O(N^2) 이 나올 수도 있다. 이미 정렬이 되어 있는 경우 분할정복의 이점을 살리지 못하기 때문..
- 거의 대부분의 경우에는 퀵정렬이 빠르지만, 이미 정렬이 되어있는 경우에는 삽입정렬이 빠를 수 있다.