# 목차

[1. 자료구조](#자료구조)  
[2. 데이터베이스](#데이터베이스-dbms)  
[3. 데이터 입출력](#데이터-입출력)  
[4. 절차형 SQL](#절차형-sql)  
[5. 개발 지원 도구](#개발-지원-도구)  
[6. 소프트웨어 패키징](#소프트웨어-패키징)  
[7. 릴리즈 노트](#릴리즈-노트)  
[8. 디지털 저작권 관리](#디지털-저작권-관리)  



# 자료구조

1. 분류
    - 선형 구조 
        - 배열 Array
        - 스택 Stack
        - 큐 Queue
        - 데크 Deque
        - 선형 리스트 Linear List = 연속 리스트 (순차적), 연결 리스트 (비순차적)

    - 비선형 구조
        - 트리 Tree
        - 그래프 Graph

2. 배열 Array
    - 정적인 자료구조로 기억장소의 추가가 어렵고 메모리의 낭비가 발생
    - 첨자를 이용
    - 반복적인 데이터 처리 작업에 적합한 구조
    - 데이터마다 동일한 이름의 변수를 사용해 처리가 간편

3. 스택 Stack
    - 리스트의 한쪽 끝으로만 자료 삽입, 삭제 작업이 이루어지는 자료구조
    - 후입선출 LIFO (Last In First Out)

4. 큐 Queue
    - 리스트의 한쪽에서는 삽입 작업, 다른 한쪽에서는 삭제 작업이 이루어지는 자료구조
    - 선입선출 FIFO (First In First Out)

5. 데크 Deque
    - 리스트의 양쪽 끝에서 삽입과 삭제 작업을 할 수 있는 자료구조

6. 선형리스트 Linear List
    - 연속 리스트 
        - 배열과 같이 연속되는 기억장소에 저장되는 자료구조
        - 기억장소 이용 효율은 밀도가 1로서 가장 좋음
        - 중간에 데이터를 삽입하기 위해 연속된 비니 공간이 있어야 함
        - 삽입, 삭제 시 자료의 이동이 필요함

    - 연결 리스트
        - 노드의 포인터 부분을 이용해 서로 연결시킨 자료구조
        - 노드의 삽입, 삭제 작업이 용이
        - 기억 공간이 연속적으로 놓여있지 않아도 저장 가능
        - 포인터가 필요하기 때문에 순차 리스트에 비해 기억 공간 효율이 좋지 않음
        - 접근 속도가 느림
        - 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다

7. **트리 Tree**
    - 노드와 가지를 이용해 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
    - 노드 Node : 트리의 기본 요소
    - 근 노드 Root Node : 트리의 맨 위에 있는 노드
    - **디그리 Degree** : 각 노드에서 뻗어 나온 가지의 수
    - **단말 노드 Terminal Node** : 자식이 하나도 없는 노드, 디그리가 0인 노드

8. 그래프
    - 방향 그래프
        - 방향이 있는 그래프
        - n개의 정점으로 구성된 방향 그래프의 최대 간선 수 = n(n-1)

    - 무방향 그래프
        - 방향이 없는 그래프
        - n개의 정점으로 구성된 무방향 그래프의 최대 간선 수 = n(n-1)/2


# 데이터베이스 DBMS

1. **데이터베이스 Database**
    - 공용 데이터 : 공동으로 소유하고 유지하는 자료
    - 통합된 데이터 : 자료의 중복을 최대로 배제한 데이터의 모임
    - 운영 데이터 : 고유한 업무를 수행하는 데 없어서는 안 될 자료
    - 저장된 데이터 : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료

2. DBMS (Database Management System) 데이터베이스 관리 시스템
    - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어
    - 정의 기능 : 타입과 구조에 대한 정의, 이용방식, 제약 조건 등을 명시 (DDL)
    - 조작 기능 : 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능 (DML)
    - 제어 기능 : 무결성, 보안, 권한, 병행 제어 (DCL)


# 데이터 입출력

1. SQL (Structured Query Language)
    - 관계대수와 관계해석을 기초로 한 혼합 데이터 언어

    - 데이터 정의어 (DDL)
    : 도메인, 스키마, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어

    - 데이터 조작어 (DML)
    : 검색, 삽입, 갱신, 삭제로 저장된 데이터를 실질적으로 처리하는데 사용하는 언어

    - 데이터 제어어 (DCL)
    : 데이터의 무결성, 보안, 회복, 병행 제어 등을 정의하는데 사용되는 언어

2. 데이터 접속
    - 소프트웨어의 기능 구현을 위해 프로그래밍 코드와 데이터베이스의 데이터를 연결Mapping 하는 것

    - **SQL Mapping**
    : 프로그래밍 코드 내 SQL을 직접 입력해 DBMS의 데이터에 접속하는 기술
    - **ORM Object-Relational Mapping**
    : 객체와 관계형데이터베이스 RDB의 데이터를 연결하는 기술 (Django)

3. **트랜잭션 Transaction**
    - 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
    - 한꺼번에 모두 수행되어야 할 일련의 연산들

    - COMMIT : 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어

    - ROLLBACK : 트랜잭션 처리가 비정상으로 종료되어 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산

    - SAVEPOINT (=CHECKPOINT) : 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러개 지정 가능


# 절차형 SQL

1. 개요
    - 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
    - 일반적인 프로그래밍 언어에 비해 효율이 떨어짐
    - 연속적인 작업들을 처리하는데 적합
    - Begin ~ End 형식으로 작성되는 블록 구조로 기능별 모듈화 가능

    - 프로시저 Procedure : 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 아예 하지 않음
    - 트리거 Trigger : 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업을 자동 수행
    - 사용자 정의 함수 : SQL을 사용해 일련의 작업을 연속적으로 처리함, 종료 시 RETURN을 사용해 처리 결과를 단일값으로 반환

2. 테스트와 디버깅
    - 테스트 전 구문 오류나 참조 오류의 존재 여부 확인
    - 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 내용 확인
    - DB에 변화를 줄 수 있는 SQL문을 주석으로 처리하고 디버깅 수행

3. 쿼리 성능 최적화
    - 데이터 입, 출력 어플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것
    - 성능 측정 도구 APM 을 사용해 최적화할 쿼리를 선정
    - 최적화할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성


# 개발 지원 도구

1. 통합 개발 환경 IDE
    - 개발에 필요한 환경 즉 편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합해 제공하는 것
    - 이클립스, Visual Studio, X code, Android Studio 등

2. 빌드 자동화 도구
    - 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어

    - Ant
        - 자바 프로젝트의 공식적인 빌드 자동화 도구
        - XML 기반의 빌드 스크립트 사용
        - 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의
        - 스크립트의 재사용이 어려움

    - Maven 
        - Ant의 대안으로 개발
        - 규칙이나 표준이 존재
        - 컴파일과 빌드를 동시에 수행 가능
        - 의존성을 설정하여 라이브러리를 관리

    - **Gradle**
        - Ant, Maven 보완해 개발
        - Android Studio 의 공식 빌드 도구
        - 의존성 사용
        - 그루비 Groovy 기반의 빌드 스크립트 사용
        - 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
        - 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능 지원 -> 빌드 속도 향상

    - **Jenkins**
        - JAVA 기반의 오픈 소스 형태로 가장 많이 사용되는 빌드 자동화 도구
        - 서블릿 컨테이너에서 실행되는 서버 기반 도구
        - 대부분의 형상 관리 도구와 연동 가능
        - 친숙한 Web GUI 제공


# 소프트웨어 패키징
    
- 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
- 개발자가 아닌 사용자를 중심으로 진행

- OS, CPU, 메모리 등에 필요한 최소 환경 정의
- 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
- 다양한 사용자의 요구사항 반영

1. 작업 순서
    - 기능 식별 -> 모듈화 -> 빌드 진행 -> 사용자 환경 분석 -> 패키징 및 적용 시험 -> 패키징 변경 개선 -> 배포

2. 고려사항
    - 보안 고려
    - 사용자 편의성을 위한 복잡성, 비효율성 문제 고려
    - 제품 SW 종류에 적합한 암호화 알고리즘 적용
    - 다양한 기종 연동 고려


# 릴리즈 노트

- 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서
- 개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공
- 개발팀에서 제공하는 소프트웨어 사양에 대한 최종 승인을 얻은 후 문서화되어 제공


# 디지털 저작권 관리

- 디지털 컨텐츠의 전 과정에 걸쳐 사용되는 디지털 컨텐츠 관리 및 보호 기술

1. 디지털 저작권 관리 DRM 의 흐름
    - 제공자 : 컨텐츠를 제공하는 저작권자
    - 분배자 : 암호화된 컨텐츠를 유동하는 곳이나 사람
    - 소비자 : 컨텐츠를 구매하여 사용하는 주체
    - 패키저 Packager : 컨텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
    - 클리어링 하우스 : 저작권에 대한 사용 권한, 라이센스 발급, 사용량에 따른 결제 관리 등을 수행
    - DRM 컨트롤러 : 배포된 컨텐츠의 이용 권한을 통제하는 프로그램
    - 보안 컨테이너 : 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

2. **디지털 저작권 관리의 기술 요소**
    - 암호화 : 컨텐츠 및 라이센스를 암호화하고 전자서명을 할 수 있는 기술
    - 키 관리 : 컨텐츠를 암호화한 키에 대한 저장 및 분배 기술
    - 식별 기술 : 컨텐츠에 대한 식별 체계 표현 기술
    - 저작권 표현 : 라이선스의 내용 표현 기술
    - 암호화 파일 생성 : 컨텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
    - 정책 관리 : 라이센스 발급 및 사용에 대한 정책 표현 및 관리 기술
    - 크랙 방지 : 크랙에 의한 컨텐츠 사용 방지 기술
    - 인증 : 라이센스 발급 및 사용의 기준이 되는 사용자 인증 기술


# 형상 관리

1. 소프트웨어 패키징의 형상 관리 SCM, Software Configuration Management
    - 형상관리는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동임
    - 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행

2. 중요성
    - 변경 사항을 체계적으로 추적하고 통제
    - 무절제한 변경 방지

3. 형상 관리 기능
    - 형상 식별 : 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
    - 형상 통제 : 식별된 형상 항목에 대한 변경 요구를 검토
    - 형상 감사 : 기준선의 무결성을 평가하기 위해
    - 형상 기록 : 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

4. 제품 소프트웨어의 형상 관리 역할
    - 배포본 관리에 유용
    - 불필요한 사용자의 소스 수정 제한
    - 동일한 프로젝트에 대해 여러 개발자 동시 개발 가능


# 버전 관리 도구

1. 공유 폴더 방식
    - 로컬 컴퓨터의 공유 폴더에 저장되어 관리
    - 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사함
    - 담당자는 공유 폴더의 파일을 자기 PC로 복사해 컴파일한 후 이상 유무 확인
    - 파일의 변경 사항을 데이터베이스에 기록하며 관리
    - SCCS, RCS, PVCS, QVCS

2. 클라이언트/서버 방식
    - 중앙 시스템(서버)에 저장되어 관리되는 방식
    - 개발자별로 자신의 PC로 복사해 작업한 후 변경 내용을 중앙 서버에 반영
    - 모든 버전 관리는 서버에서 수행
    - 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
    - 서버에 문제가 생기면 다른 개발자와의 협업 및 버전 관리 작업은 중단됨
    - CVS, SVN(Subversion)

3. 분산 저장소 방식
    - 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리
    - 원격 저장소의 자료를 자신의 로컬 저장소로 복사해 작업한 후 로컬 저장소에서 Commit 한 뒤 원격 저장소에 Push
    - 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능
    - 처리 속도가 빠름
    - Git, Bitkeeper

4. SVN (Subversion)
    - CVS 를 개선한 것
    - 커밋할 때마다 리비전이 1씩 증가
    - 서버는 주로 유닉스 사용
    - 오픈 소스로 무료 사용 가능
    - CVS의 단점이었던 파일이나 디렉토리 이름 변경, 이동이 가능

5. Git
    - 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
    - 로컬 저장소는 개발자들이 본인의 실제 개발을 진행하는 장소
    - 브랜치를 이용하면 다양한 형태의 기능 테스팅 가능
    - 파일의 변화를 스냅샷으로 저장
    - 버전의 흐름 파악 가능
    - git init -> git remote add -> git add -all -> git commit -> git push


# 어플리케이션 테스트

- 결함을 찾아내는 일련의 행위
- 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인
- 소프트웨어가 기능을 정확히 수행하는지 검증

1. 기본 원리
    - 테스팅은 결함이 존재함을 밝히는 것
        - 결함이 없다고는 증명할 수 없음
    - 완벽한 테스팅은 불가능
    - 개발 초기에 테스팅 시작
        - 테스팅 기간 단축, 재작업 감소로 개발 기간 단축 및 결함 예방
    - 결함 집중
        - 파레토법칙 (20%의 모듈에서 80%의 결함 발견)
    - 살충제 패러독스
        - 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
    - 테스팅은 정황에 의존적
        - 소프트웨어 성격에 맞게 테스트 실시
    - 오류-부재의 궤변
        - 요구사항을 충족시켜주지 못한다면 결함이 없다고 해도 품질이 높다고 볼 수 없음


# 어플리케이션 테스트의 분류

1. 프로그램 실행 여부에 따른 테스트
    - 정적 테스트 : 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트

    - 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트

2. 테스트 기반에 따른 테스트
    - 명세 기반 테스트 : 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 테스트

    - 구조 기반 테스트 : 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트

    - 경험 기반 테스트 : 테스터의 경험을 기반으로 수행하는 테스트

3. 시각에 따른 테스트
    - 검증 테스트 : 개발자의 시각에서 제품의 생산 과정을 테스트
        - 단위, 통합, 시스템 테스트
    - 확인 테스트 : 사용자의 시각에서 생산된 제품의 결과를 테스트
        - **인수 테스트 (알파, 베타 테스트)**

4. 목적에 따른 테스트
    - 회복 테스트
    - 안전 테스트
    - 강도 테스트
    - 성능 테스트
    - 구조 테스트
    - **회귀 테스트** : 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인
    - 병행 테스트