# 목차

[1. 자료구조](#자료구조)  
[2. 데이터베이스](#데이터베이스-dbms)  
[3. 데이터 입출력](#데이터-입출력)  
[4. 절차형 SQL](#절차형-sql)  
[5. 개발 지원 도구](#개발-지원-도구)  
[6. 소프트웨어 패키징](#소프트웨어-패키징)  
[7. 릴리즈 노트](#릴리즈-노트)  
[8. 디지털 저작권 관리](#디지털-저작권-관리)  
[9. 형상관리](#형상-관리)  
[10. 버전 관리 도구](#버전-관리-도구)  
[11. 어플리케이션 테스트](#어플리케이션-테스트)  
[12. 어플리케이션 테스트 분류](#어플리케이션-테스트의-분류)  
[13. 화이트박스 테스트, 블랙박스 테스트](#화이트박스-테스트-블랙박스-테스트)  
[14. 개발 단계에 따른 어플리케이션 테스트](#개발-단계에-따른-어플리케이션-테스트)  
[15. 통합 테스트](#통합-테스트)  
[16. 테스트 케이스, 시나리오, 오라클, 하네스](#테스트-케이스-시나리오-오라클-하네스)  
[17. 결함 관리](#결함-관리)  
[18. 어플리케이션 성능 분석](#어플리케이션-성능-분석)
[19. 모듈 연계](#모듈-연계)  
[20. 인터페이스 구현, 보안](#인터페이스-구현-인터페이스-보안)  
[21. 인터페이스 구현 검증, 오류 확인](#인터페이스-구현-검증-인터페이스-오류-확인)  
[22. 트리 순회 방법](#트리-순회-방법)  
[23. 이진 트리](#이진-트리)  
[24. 논리/물리 데이터 저장소](#논리-데이터-저장소)
[25. 인덱스](#인덱스)  
[26. 뷰](#뷰-view)  
[27. 클러스터, 파티션](#클러스터)  
[28. 알고리즘 설계 기법](#알고리즘-설계-기법)  
[29. 시간복잡도에 따른 알고리즘](#시간-복잡도에-따른-알고리즘)  
[30. IPC](#ipc-inter-process-communication)
[31. 정렬 알고리즘](#정렬-알고리즘)
[32. AJAX](#ajax)  
[33. 해싱함수](#해싱함수)  
[34. 워크스루, 인스펙션](#워크스루)  



# 자료구조

1. 분류
    - 선형 구조 
        - 배열 Array
        - 스택 Stack
        - 큐 Queue
        - 데크 Deque
        - 선형 리스트 Linear List = 연속 리스트 (순차적), 연결 리스트 (비순차적)

    - 비선형 구조
        - 트리 Tree
        - 그래프 Graph

2. 배열 Array
    - 정적인 자료구조로 기억장소의 추가가 어렵고 메모리의 낭비가 발생
    - 첨자를 이용
    - 반복적인 데이터 처리 작업에 적합한 구조
    - 데이터마다 동일한 이름의 변수를 사용해 처리가 간편

3. 스택 Stack
    - 리스트의 한쪽 끝으로만 자료 삽입, 삭제 작업이 이루어지는 자료구조
    - 후입선출 LIFO (Last In First Out)

4. 큐 Queue
    - 리스트의 한쪽에서는 삽입 작업, 다른 한쪽에서는 삭제 작업이 이루어지는 자료구조
    - 선입선출 FIFO (First In First Out)

5. 데크 Deque
    - 리스트의 양쪽 끝에서 삽입과 삭제 작업을 할 수 있는 자료구조

6. 선형리스트 Linear List
    - 연속 리스트 
        - 배열과 같이 연속되는 기억장소에 저장되는 자료구조
        - 기억장소 이용 효율은 밀도가 1로서 가장 좋음
        - 중간에 데이터를 삽입하기 위해 연속된 비니 공간이 있어야 함
        - 삽입, 삭제 시 자료의 이동이 필요함

    - 연결 리스트
        - 노드의 포인터 부분을 이용해 서로 연결시킨 자료구조
        - 노드의 삽입, 삭제 작업이 용이
        - 기억 공간이 연속적으로 놓여있지 않아도 저장 가능
        - 포인터가 필요하기 때문에 순차 리스트에 비해 기억 공간 효율이 좋지 않음
        - 접근 속도가 느림
        - 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 힘들다

7. **트리 Tree**
    - 노드와 가지를 이용해 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
    - 노드 Node : 트리의 기본 요소
    - 근 노드 Root Node : 트리의 맨 위에 있는 노드
    - **디그리 Degree** : 각 노드에서 뻗어 나온 가지의 수
    - **단말 노드 Terminal Node** : 자식이 하나도 없는 노드, 디그리가 0인 노드

8. 그래프
    - 방향 그래프
        - 방향이 있는 그래프
        - n개의 정점으로 구성된 방향 그래프의 최대 간선 수 = n(n-1)

    - 무방향 그래프
        - 방향이 없는 그래프
        - n개의 정점으로 구성된 무방향 그래프의 최대 간선 수 = n(n-1)/2


# 데이터베이스 DBMS

1. **데이터베이스 Database**
    - 공용 데이터 : 공동으로 소유하고 유지하는 자료
    - 통합된 데이터 : 자료의 중복을 최대로 배제한 데이터의 모임
    - 운영 데이터 : 고유한 업무를 수행하는 데 없어서는 안 될 자료
    - 저장된 데이터 : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료

2. DBMS (Database Management System) 데이터베이스 관리 시스템
    - 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어
    - 정의 기능 : 타입과 구조에 대한 정의, 이용방식, 제약 조건 등을 명시 (DDL)
    - 조작 기능 : 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능 (DML)
    - 제어 기능 : 무결성, 보안, 권한, 병행 제어 (DCL)


# 데이터 입출력

1. SQL (Structured Query Language)
    - 관계대수와 관계해석을 기초로 한 혼합 데이터 언어

    - 데이터 정의어 (DDL)
    : 도메인, 스키마, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어

    - 데이터 조작어 (DML)
    : 검색, 삽입, 갱신, 삭제로 저장된 데이터를 실질적으로 처리하는데 사용하는 언어

    - 데이터 제어어 (DCL)
    : 데이터의 무결성, 보안, 회복, 병행 제어 등을 정의하는데 사용되는 언어

2. 데이터 접속
    - 소프트웨어의 기능 구현을 위해 프로그래밍 코드와 데이터베이스의 데이터를 연결Mapping 하는 것

    - **SQL Mapping**
    : 프로그래밍 코드 내 SQL을 직접 입력해 DBMS의 데이터에 접속하는 기술
    - **ORM Object-Relational Mapping**
    : 객체와 관계형데이터베이스 RDB의 데이터를 연결하는 기술 (Django)

3. **트랜잭션 Transaction**
    - 데이터베이스의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
    - 한꺼번에 모두 수행되어야 할 일련의 연산들

    - COMMIT : 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어

    - ROLLBACK : 트랜잭션 처리가 비정상으로 종료되어 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산

    - SAVEPOINT (=CHECKPOINT) : 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어, 여러개 지정 가능


# 절차형 SQL

1. 개요
    - 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
    - 일반적인 프로그래밍 언어에 비해 효율이 떨어짐
    - 연속적인 작업들을 처리하는데 적합
    - Begin ~ End 형식으로 작성되는 블록 구조로 기능별 모듈화 가능

    - 프로시저 Procedure : 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 아예 하지 않음
    - 트리거 Trigger : 입력, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업을 자동 수행
    - 사용자 정의 함수 : SQL을 사용해 일련의 작업을 연속적으로 처리함, 종료 시 RETURN을 사용해 처리 결과를 단일값으로 반환

2. 테스트와 디버깅
    - 테스트 전 구문 오류나 참조 오류의 존재 여부 확인
    - 오류 및 경고 메시지가 상세히 출력되지 않으므로 SHOW 명령어를 통해 내용 확인
    - DB에 변화를 줄 수 있는 SQL문을 주석으로 처리하고 디버깅 수행

3. 쿼리 성능 최적화
    - 데이터 입, 출력 어플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것
    - 성능 측정 도구 APM 을 사용해 최적화할 쿼리를 선정
    - 최적화할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스 재구성


# 개발 지원 도구

1. 통합 개발 환경 IDE
    - 개발에 필요한 환경 즉 편집기, 컴파일러, 디버거 등의 다양한 툴을 하나의 인터페이스로 통합해 제공하는 것
    - 이클립스, Visual Studio, X code, Android Studio 등

2. 빌드 자동화 도구
    - 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업들을 수행하는 소프트웨어

    - Ant
        - 자바 프로젝트의 공식적인 빌드 자동화 도구
        - XML 기반의 빌드 스크립트 사용
        - 정해진 규칙이나 표준이 없어 개발자가 모든 것을 정의
        - 스크립트의 재사용이 어려움

    - Maven 
        - Ant의 대안으로 개발
        - 규칙이나 표준이 존재
        - 컴파일과 빌드를 동시에 수행 가능
        - 의존성을 설정하여 라이브러리를 관리

    - **Gradle**
        - Ant, Maven 보완해 개발
        - Android Studio 의 공식 빌드 도구
        - 의존성 사용
        - 그루비 Groovy 기반의 빌드 스크립트 사용
        - 실행할 처리 명령들을 모아 태스크로 만든 후 태스크 단위로 실행
        - 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능 지원 -> 빌드 속도 향상

    - **Jenkins**
        - JAVA 기반의 오픈 소스 형태로 가장 많이 사용되는 빌드 자동화 도구
        - 서블릿 컨테이너에서 실행되는 서버 기반 도구
        - 대부분의 형상 관리 도구와 연동 가능
        - 친숙한 Web GUI 제공


# 소프트웨어 패키징
    
- 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
- 개발자가 아닌 사용자를 중심으로 진행

- OS, CPU, 메모리 등에 필요한 최소 환경 정의
- 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
- 다양한 사용자의 요구사항 반영

1. 작업 순서
    - 기능 식별 -> 모듈화 -> 빌드 진행 -> 사용자 환경 분석 -> 패키징 및 적용 시험 -> 패키징 변경 개선 -> 배포

2. 고려사항
    - 보안 고려
    - 사용자 편의성을 위한 복잡성, 비효율성 문제 고려
    - 제품 SW 종류에 적합한 암호화 알고리즘 적용
    - 다양한 기종 연동 고려


# 릴리즈 노트

- 개발 과정에서 정리된 릴리즈 정보를 고객과 공유하기 위한 문서
- 개선된 작업이 있을 때마다 관련 내용을 릴리즈 노트에 담아 제공
- 개발팀에서 제공하는 소프트웨어 사양에 대한 최종 승인을 얻은 후 문서화되어 제공


# 디지털 저작권 관리

- 디지털 컨텐츠의 전 과정에 걸쳐 사용되는 디지털 컨텐츠 관리 및 보호 기술

1. 디지털 저작권 관리 DRM 의 흐름
    - 제공자 : 컨텐츠를 제공하는 저작권자
    - 분배자 : 암호화된 컨텐츠를 유동하는 곳이나 사람
    - 소비자 : 컨텐츠를 구매하여 사용하는 주체
    - 패키저 Packager : 컨텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
    - 클리어링 하우스 : 저작권에 대한 사용 권한, 라이센스 발급, 사용량에 따른 결제 관리 등을 수행
    - DRM 컨트롤러 : 배포된 컨텐츠의 이용 권한을 통제하는 프로그램
    - 보안 컨테이너 : 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

2. **디지털 저작권 관리의 기술 요소**
    - 암호화 : 컨텐츠 및 라이센스를 암호화하고 전자서명을 할 수 있는 기술
    - 키 관리 : 컨텐츠를 암호화한 키에 대한 저장 및 분배 기술
    - 식별 기술 : 컨텐츠에 대한 식별 체계 표현 기술
    - 저작권 표현 : 라이선스의 내용 표현 기술
    - 암호화 파일 생성 : 컨텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
    - 정책 관리 : 라이센스 발급 및 사용에 대한 정책 표현 및 관리 기술
    - 크랙 방지 : 크랙에 의한 컨텐츠 사용 방지 기술
    - 인증 : 라이센스 발급 및 사용의 기준이 되는 사용자 인증 기술


# 형상 관리

1. 소프트웨어 패키징의 형상 관리 SCM, Software Configuration Management
    - 형상관리는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동임
    - 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행

2. 중요성
    - 변경 사항을 체계적으로 추적하고 통제
    - 무절제한 변경 방지

3. 형상 관리 기능
    - 형상 식별 : 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
    - 형상 통제 : 식별된 형상 항목에 대한 변경 요구를 검토
    - 형상 감사 : 기준선의 무결성을 평가하기 위해
    - 형상 기록 : 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

4. 제품 소프트웨어의 형상 관리 역할
    - 배포본 관리에 유용
    - 불필요한 사용자의 소스 수정 제한
    - 동일한 프로젝트에 대해 여러 개발자 동시 개발 가능


# 버전 관리 도구

1. 공유 폴더 방식
    - 로컬 컴퓨터의 공유 폴더에 저장되어 관리
    - 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사함
    - 담당자는 공유 폴더의 파일을 자기 PC로 복사해 컴파일한 후 이상 유무 확인
    - 파일의 변경 사항을 데이터베이스에 기록하며 관리
    - SCCS, RCS, PVCS, QVCS
    - **RCS (Revision Control System)**
        - 다수의 사용자가 동시에 파일 수정할 수 없도록 파일 잠금 방식으로 버전 관리

2. 클라이언트/서버 방식
    - 중앙 시스템(서버)에 저장되어 관리되는 방식
    - 개발자별로 자신의 PC로 복사해 작업한 후 변경 내용을 중앙 서버에 반영
    - 모든 버전 관리는 서버에서 수행
    - 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
    - 서버에 문제가 생기면 다른 개발자와의 협업 및 버전 관리 작업은 중단됨
    - CVS, SVN(Subversion)

3. 분산 저장소 방식
    - 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리
    - 원격 저장소의 자료를 자신의 로컬 저장소로 복사해 작업한 후 로컬 저장소에서 Commit 한 뒤 원격 저장소에 Push
    - 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용해 작업 가능
    - 처리 속도가 빠름
    - Git, Bitkeeper

4. SVN (Subversion)
    - CVS 를 개선한 것
    - 커밋할 때마다 리비전이 1씩 증가
    - 서버는 주로 유닉스 사용
    - 오픈 소스로 무료 사용 가능
    - CVS의 단점이었던 파일이나 디렉토리 이름 변경, 이동이 가능

5. Git
    - 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
    - 로컬 저장소는 개발자들이 본인의 실제 개발을 진행하는 장소
    - 브랜치를 이용하면 다양한 형태의 기능 테스팅 가능
    - 파일의 변화를 스냅샷으로 저장
    - 버전의 흐름 파악 가능
    - git init -> git remote add -> git add -all -> git commit -> git push


# 어플리케이션 테스트

- 결함을 찾아내는 일련의 행위
- 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인
- 소프트웨어가 기능을 정확히 수행하는지 검증

1. 기본 원리
    - 테스팅은 결함이 존재함을 밝히는 것
        - 결함이 없다고는 증명할 수 없음
    - 완벽한 테스팅은 불가능
    - 개발 초기에 테스팅 시작
        - 테스팅 기간 단축, 재작업 감소로 개발 기간 단축 및 결함 예방
    - 결함 집중
        - 파레토법칙 (20%의 모듈에서 80%의 결함 발견)
    - 살충제 패러독스
        - 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함
    - 테스팅은 정황에 의존적
        - 소프트웨어 성격에 맞게 테스트 실시
    - 오류-부재의 궤변
        - 요구사항을 충족시켜주지 못한다면 결함이 없다고 해도 품질이 높다고 볼 수 없음


# 어플리케이션 테스트의 분류

1. 프로그램 실행 여부에 따른 테스트
    - 정적 테스트 : 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트

    - 동적 테스트 : 프로그램을 실행하여 오류를 찾는 테스트

2. 테스트 기반에 따른 테스트
    - 명세 기반 테스트 : 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 테스트

    - 구조 기반 테스트 : 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트

    - 경험 기반 테스트 : 테스터의 경험을 기반으로 수행하는 테스트

3. 시각에 따른 테스트
    - 검증 테스트 : 개발자의 시각에서 제품의 생산 과정을 테스트
        - 단위, 통합, 시스템 테스트
    - 확인 테스트 : 사용자의 시각에서 생산된 제품의 결과를 테스트
        - **인수 테스트 (알파, 베타 테스트)**

4. 목적에 따른 테스트
    - 회복 테스트
    - 안전 테스트
    - 강도 테스트
    - 성능 테스트
    - 구조 테스트
    - **회귀 테스트** : 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인
    - 병행 테스트


# 화이트박스 테스트, 블랙박스 테스트

1. **화이트박스 테스트**
    - 모듈 안의 작동을 직접 볼 수 있음
    - 내부의 논리적인 모든 경로를 테스트해 테스트 케이스 설계
    - 소스 코드의 모든 문장을 한번 이상 수행함으로써 진행됨
    - 논리적 경로 점검

    - 기초 경로 검사 : 대표적인 화이트박스 테스트 기법
    - 제어 구조 검사 : 조건 검사, 루프 검사, 데이터 흐름 검사

2. **블랙박스 검사**
    - 모듈 안에서 어떤 일이 일어나는지 알 수 없음
    - 소프트웨어가 수행할 특정 기능을 알기 위해 각 기능이 완전히 작동되는 것을 입증하는 테스트로 기능 테스트라고도 함
    - 소프트웨어 인터페이스에서 실시되는 테스트
    - 프로그램 구조 고려X

    - 동치 분할 검사 : 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 해 테스트 케이스를 정하고, 입력 자료에 맞는 결과가 출력되는지 확인
    - 경계값 분석 : 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용해 경계값을 테스트 케이스로 선정해 검사
    - 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 뒤 효용성이 높은 테스트 케이스를 선정
    - 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공해 동일한 결과가 출력되는지 테스트
    - 오류 예측 검사 : 다른 블랙박스 테스트 기법으로 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사 기법


# 개발 단계에 따른 어플리케이션 테스트

1. 단위 테스트 Unit test
    - 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
    - 주로 구조 기반 테스트를 시행

2. 통합 테스트 Integration test
    - 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트
    - 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류 검사
    - 빅뱅 테스트, 상향식 테스트, 하향식 테스트

3. 시스템 테스트
    - 개발된 소프트웨어가 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
    - 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트 수행해야 함
    - 기능적 요구사항(블랙박스 테스트), 비기능적 요구사항(화이트박스 테스트)

4. **인수 테스트**
    - 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두는 테스트
    - 알파 테스트 : 통제된 환경에서 사용자가 개발자와 함께 확인하면서 행하는 테스트 기법
    - 베타 테스트 : 통제되지 않은 환경에서 여러 명의 사용자가 행하는 테스트 기법


# 통합 테스트

1. 상향식 통합 테스트
    - 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
    - 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터 필요

    - 하위 모듈들을 클러스터로 결합 -> 더미 모듈인 **드라이버 작성** -> 통합된 클러스터 단위로 테스트 -> 테스트 완료 후 클러스터는 프로그램 구조의 상위로 이동해 결합하고 드라이버는 실제 모듈로 대체됨

2. 하향식 통합 테스트
    - 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
    - 깊이 우선 통합법, 넓이 우선 통합법
    - 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
    
    - 주요 제어 모듈의 종속 모듈은 **스텁으로 대체** -> 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 스텁들이 한번에 하나씩 실제 모듈로 교체됨 -> 모듈이 통합될때마다 테스트 실시 -> 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시

3. 혼합식 통합 테스트 
    - 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용해 최적의 테스트를 지원
    - 샌드위치식 통합 테스트 방법


# 테스트 케이스, 시나리오, 오라클, 하네스

1. 테스트 케이스 Test Case
    - 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
    - 명세 기반 테스트(블랙박스 테스트)의 설계 산출물에 해당
    - 미리 설계해두면 테스트 오류 방지 및 테스트 수행 자원의 낭비를 줄일 수 있음

2. 테스트 시나리오 Test Scenario
    - 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합
    - 여러 개의 시나리오로 분리하여 작성

3. 테스트 오라클 Test Oracle
    - 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입해 비교하는 활동
    - 모든 테스트 케이스에 적용할 수 없음, 값을 수학적 기법을 이용해 구할 수 있음, 프로그램 실행, 결과 비교, 커버리지 측정 등을 자동화할 수 있음

4. 테스트 하네스
    - 테스트 드라이버 : 컴포넌트나 시스템을 제어/호출하는 컴포넌트를 대체하는 소프트웨어 컴포넌트 또는 테스트 툴. **필요한 데이터를 인자를 통해 넘겨주고, 테스트 완료 후 결과값을 받는 역할**
    - 테스트 스텁 : 골격만 있는 특별한 목적의 소프트웨어 컴포넌트를 구현한 것. 스텁을 호출하거나 스텁에 의존적인 컴포넌트를 개발하거나 테스트할 때 사용됨. **인자를 통해 받은 값을 가지고 수행한 후 그 결과를 테스트할 모듈에 넘겨주는 역할**
    - 테스트 슈트 : 테스트 케이스의 집합
    - 테스트 케이스 : 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목 명세서
    - 테스트 스크립트 : 자동화된 테스트 실행 절차에 대한 명세서
    - 목 오브젝트 : 행위를 조건부로 입력해두면 상황에 맞는 예정된 행위를 수행하는 객체


# 결함 관리

1. 결함 상태 추적

    - 결함 분포 : 결함 수 측정
    - 결함 추세 : 테스트 진행 시간에 따른 결함 수의 추이 분석
    - 결함 에이징 : 특정 결함 상태로 지속되는 시간 측정

2. 결함 추적 순서

    - 결함 등록 : 결함이 등록된 상태
    - 결함 검토 : 담당자에 의해 검토된 상태
    - 결함 할당 : 결함이 할당된 상태
    - 결함 수정 : 개발자가 결함 수정을 완료한 상태
    - 결함 조치 보류 : 결함의 수정이 불가능해 연기된 상태
    - 결함 종료 : 결함이 해결되어 테스터와 품질 관리 담당자가 종료를 승인한 상태
    - 결함 해제 : 결함이 아니라고 판명한 상태

3. 결함 심각도, 결함 우선순위

    - 결함 심각도 : 치명적 > 주요 > 보통 > 경미 > 단순
    - 결함 우선순위 : 치명적 > 높음 > 보통 > 낮음


# 어플리케이션 성능 분석

1. **어플리케이션 성능**
    - 처리량
    - 응답 시간 : 요청을 전달한 시간부터 응답이 도착할 때까지
    - 경과 시간 : 작업을 의뢰한 시간부터 처리가 완료될 때까지
    - 자원 사용률

2. 어플리케이션 성능 저하 원인 분석
    - DB에 필요 이상의 많은 데이터를 요청한 경우
    - 커넥션 풀의 크기를 너무 작거나 크게 설정한 경우
    - 미들웨어를 사용한 후 종료하지 않아 연결 누수가 발생한 경우
    - 대량의 파일을 업로드하거나 다운로드해 처리 시간이 길어진 경우

3. 소스 코드 최적화
    - 클린 코드 작성 원칙 : 가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화

4. **소스 코드 품질분석 도구의 종류**
    - 정적 도구 : pmd, cppcheck, checkstyle, SonarQube, ccm, cobertuna
    - 동적 도구 : Avalanche, Valgrind


# 모듈 연계

1. EAI (Enterprise Application Integration)

    기업 내 각종 어플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션

    - **포인트 투 포인트** : 점대점으로 연결하는 방식, 변경 및 재사용이 어려움
    - **허브 앤 스포크** : 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식, 확장 및 유지보수가 용이하지만 허브 장애 발생 시 시스템 전체에 영향
    - **메시지 버스** : 어플리케이션 사이에 미들웨어를 둬 처리하는 방식, 확장성이 뛰어나며 대용량 처리가 가능
    - **하이브리드** : 허브 앤 스포크와 메시지 버스의 혼합 방식, 데이터 병목 현상을 최소화할 수 있음

2. ESB (Enterprise Service Bus)
    - 어플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
    - 어플리케이션 통합 측면에서 EAI와 유사하지만 어플리케이션 보다는 서비스 중심의 통합을 지향
    - 결합도를 약하게 유지함
    - 관리 및 유지 보수가 쉽고, 높은 수준의 품질 지원 가능


# 인터페이스 구현, 인터페이스 보안

1. 데이터 통신을 이용한 인터페이스 구현
    - 인터페이스 형식에 맞춘 데이터 포맷을 인터페이스 대상으로 전송하고 이를 수신 측에서 파싱해 해석하는 방식
    - 주로 JSON이나 XML 형식의 데이터 포맷을 사용해 구현

    - JSON (JavaScript Object Notation) : 속성-값 쌍으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷
    - XML (eXtensible Markup Language) : 특수한 목적을 갖는 마크업 언어를 만드는데 사용되는 다목적 마크업 언어, HTML 문법이 각 웹 브라우저에서 상호 호환적이지 못하다는 문제와 SGML의 복잡함을 해결하기 위해 개발됨

2. 인터페이스 엔터티를 이용한 인터페이스 구현

    - 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티로 상호 연계하는 방식
    - 일반적으로 인터페이스 테이블을 엔터티로 활용
    - 송, 수신 인터페이스 테이블의 구조는 상황에 따라 서로 다르게 설계할 수 있음

3. 인터페이스 보안 기능 적용
    - 네트워크, 어플리케이션, 데이터베이스 영역
    
    - 스니핑 : 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형
    - 시큐어 코딩 Secure Coding : 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동

    - 입력 데이터 검증 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용


# 인터페이스 구현 검증, 인터페이스 오류 확인

1. 인터페이스 구현 검증 도구

    - xUnit : 다양한 언어를 지원하는 단위 테스트 프레임워크
    - **STAF** : 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
    - FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
    - NTAF : STAF의 장점인 재사용 및 확장성과 FitNesse의 장점인 협업 기능을 통합한 NHN의 테스트 자동화 프레임워크
    - Selenium : 다양한 브라우저 및 개발 언어를 지원하는 웹 어플리케이션 테스트 프레임워크
    - watir : Ruby 언어를 사용하는 어플리케이션 테스트 프레임워크

2. 인터페이스 오류 발생 주기적인 확인
    - 인터페이스 오류 로그 확인 : 오류를 별도의 로그파일로 생성해 보관, 자세한 오류 원인 및 내역을 확인할 수 있음
    - 인터페이스 오류 테이블 확인 : 오류사항의 확인이 쉬워 관리가 용이함, 오류사항이 구체적이지 않아 별도의 분석 필요
    - 인터페이스 감시 APM 도구 사용 : 스카우터나 제니퍼 등의 인터페이스 감시 도구를 사용해 주기적 확인


# 트리 순회 방법

- 전위 순회 : Root -> Left -> Right
- 중위 순회 : Left -> Root -> Right
- 후위 순회 : Left -> Right -> Root


# 이진 트리

디그리가 2이하인 노드로 구성돼 자식이 둘 이하로 구성된 트리


# 논리 데이터 저장소

- 개체 Entity : 관리한 대상이 되는 실체
- 속성 Attribute : 관리한 정보의 구체적 항목
- 관계 Relationship : 개체 간의 대응 관계


# 물리 데이터 저장소

논리 데이터 저장소에서 물리 데이터 저장소 모델로 변환하는 절차

- 단위 개체를 테이블로 변환 -> 속성을 칼럼으로 변환 -> UID (Unique Identifier)를 기본 키로 변환 -> 관계를 외래 키로 변환 -> 컬럼 유형과 길이 정의 -> 반정규화 수행


# 인덱스

분포도 10~15% 이내

1. 인덱스 컬럼 선정
    - 수정이 빈번하지 않는 컬럼
    - 분포도가 좋은 컬럼은 단독 인덱스로 생성
    - 인덱스들이 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성

2. 설계 시 고려사항
    - 지나치게 많은 인덱스는 오버헤드 발생
    - 인덱스만의 추가적인 저장 공간 필요
    - 넓은 범위 인덱스 처리시 오히려 전체 처리보다 많은 오버헤드를 발생시킴


# 뷰 View

- 기본 테이블로부터 유도된 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용하며 조작도 기본 테이블과 같음
- 가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨
- 데이터의 논리적 독립성을 제공할 수 있음
- 정의된 뷰로 다른 뷰를 정의할 수 있음
- 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블/뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨

1. 장점
    - 논리적 데이터 독립성 제공
    - 자동 보안 제공

2. 단점
    - 독립적인 인덱스를 가질 수 없음
    - 뷰의 정의를 ALTER로 변경할 수 없음 -> DROP하고 새로 CREATE 해야 함
    - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 제약이 따름


# 클러스터

- 인덱스의 단점을 해결한 기법 -> 분포도가 넓을수록 오히려 유리함
- 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능
- 대량의 범위를 자주 조회하는 경우 적용
- 인덱스를 사용한 처리 부담이 되는 넓은 분포도에 활용

1. 클러스터 테이블 선정
    - 수정이 빈번하지 않은 테이블
    - 처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링
    - 조인이 많아 문제가 발생하는 경우 다중 테이블 클러스터링

2. 설계시 고려사항
    - 조회 속도를 향상시켜주지만 입력, 수정, 삭제 시 성능이 저하됨


# 파티션 

- 레인지 파티셔닝 (Range Partitioning, 범위분할) : 지정한 열의 값을 기준으로 분할

- 해시 파티셔닝 (Hash Partitioning, 해시분할) : 해시 함수에 따라 데이터 분할

- 리스트 파티셔닝 (List Partitioning) : 미리 정해진 그루핑 기준에 따라 분할

- 컴포지트 파티셔닝 (Composite Partitioning, 조합 분할) : 범위분할 이후 해시 함수를 적용

- 파티션 장점 : 성능 향상, 가용성 향상, 백업 기능, 경합 감소


# 알고리즘 설계 기법

1. **분할과 정복**
    - 문제를 나눌 수 없을 때까지 나누고, 각각을 풀면서 다시 병합해 문제의 답을 얻는 알고리즘

2. **동적계획법**
    - 어떤 문제를 풀기 위해 그 문제를 더 작은 문제의 연장선으로 생각하고, 과거에 구한 해를 활용하는 방식의 알고리즘

3. **탐욕법**
    - 결정을 해야 할 때마다 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택하는 알고리즘

4. **백트래킹**
    - 어떤 노드의 유망성을 점검 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손 노드를 검색하는 알고리즘


# 시간 복잡도에 따른 알고리즘

1. O(1)
    - 상수형 복잡도, 자료 크기와 무관하게 항상 일정한 속도로 작동
    - 해시 함수

2. O(logN)
    - 로그형 복잡도, 문제를 해결하기 위한 단계의 수가 log2N 번 만큼의 수행 시간을 가짐
    - 이진 탐색

3. O(n)
    - 선형 복잡도, 입력 자료를 차례로 하나씩 모두 처리
    - 수행 시간이 자료 크기와 직접적 관계로 변함 (정비례)
    - 순차 탐색

4. O(N logN)
    - 선형 로그형 복잡도
    - 문제를 해결하기 위한 단계의 수가 Nlog2N 번 만큼 수행 시간을 가짐
    - 퀵 정렬, 합병 정렬

5. O(N^2)
    - 제곱형, 주요 처리 루트 구조가 2중인경우
    - N의 크기가 작을 때 N^2이 Nlog2N 보다 느릴 수 있음
    - 선택 정렬, 버블 정렬, 삽입 정렬


# IPC (Inter-Process Communication)

- 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
- 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현 가능

- Shared Memory : 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신 수행
- Socket : 네트워크 소켓을 이용해 네트워크를 경유하는 프로세스들 간 통신 수행
- Semaphores : 공유 자원에 대한 접근 제어를 통해 프로세스 간 통신 수행
- Pipes & named Pipes : 'Pipe' 라고 불리는 FIFO 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
- Message Queueing : 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신 수행


# 정렬 알고리즘

1. 선택 정렬, PASS 3
    1. PASS 1 : 37, 14, 17, 40, 35 -> 14, 37, 17, 40, 35

    최소값을 선택 (14) 하여 첫번째 값인 37과 바꿈
    
    2. PASS 2 : 14, 37, 17, 40, 35 -> 14, 17, 37, 40, 35

    첫번째 값인 14 제외하고 최소값인 17과 두번째 값 37을 비교하여 바꿈

    3. PASS 3 : 14, 17, 37, 40, 35 -> 14, 17, 35, 40, 37

    정답 : 14, 17, 35, 40, 37 -> 14, 17, 35, 37, 40

2. 버블 정렬, PASS 1
    1. PASS 1 : 37, 14, 17, 40, 35 -> 첫번째 37과 두번째 14를 비교해서 37 > 14 이면 바꿈, 37과 17 비교해서 바꿈, 37과 40 비교해서 바꾸지 않음, 40과 35 비교해서 바꿈

3. 삽입 정렬, PASS 4
    1. PASS 1 : 37, 14, 17, 40, 35 -> 14, 37, 17, 40, 35

    두번째 14를 37과 비교해서 수가 더 작으면 바꿔서 삽입

    2. PASS 2 : 14, 37, 17, 40, 35 -> 14, 17, 37, 40, 35

    세번째 17을 첫번째, 두번째와 비교해서 삽입함

    3. PASS 3 : 14, 17, 37, 40, 35 -> 14, 17, 37, 40, 35

    4. PASS 4 : 14, 17, 37, 40, 35 -> 14, 17, 35, 37, 40


# AJAX

- Asynchronous JavaScript and XML
- JS를 사용한 비동기 통신기술로 클라이언트와 서버 간에 XML 데이터를 주고 받는 기술


# 해싱함수

- 해싱이란, Hash Table 이라는 기억공간을 할당하고 해시 함수를 이용하여 레코드 키에 대한 Hash Table 내의 Home Address를 계산한 후 주어진 레코드를 해당 기억장소에 저장하거나 검색 작업을 수행하는 방식

1. 폴딩법
2. 제산법
3. 기수변환법
4. 숫자분석법


# 워크스루

요구사항 명세서 작성자를 포함하여 사전 검토 한 후 짧은 검토 회의를 통해 결함 발견


# 인스펙션

요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함 발견

계획 -> 사전교육 -> 준비 -> 인스펙션 회의 -> 수정 -> 후속조치
