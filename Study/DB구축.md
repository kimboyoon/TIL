# 데이터베이스 설계

1. 고려사항
    - 무결성
    - 일관성
    - 회복
    - 보안
    - 효율성
    - DB확장

2. **순서**

    1. 요구 조건 분석
    2. 개념적 설계 (정보 모델링, 개념화)
        - 독립적인 개념 스키마 모델링, *트랜잭션 모델링*
        - E-R 다이어그램 모델
    3. 논리적 설계 (데이터 모델링)
        - 목표 DBMS에 맞는 (종속적인) 논리 스키마 설계
        - *트랜잭션 인터페이스 설계*, 테이블 설계
        - 논리적 DB 구조로 매핑, 스키마의 평가 및 정제
    4. 물리적 설계 (데이터 구조화)
        - 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
        - *트랜잭션 세부 설계*
        - 저장 레코드(*데이터 타입, 값 분포, 접근 빈도*), 접근 경로 설계
    5. 구현
        - 목표 DBMS의 DDL(데이터 정의어)로 DB 생성, 트랜잭션 작성


# 데이터 모델

1. 구성 요소
    - 개체 Entity : DB에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
    - 속성 Attribute : 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
    - 관계 Relationship : 개체 간의 관계 

2. 개념적 데이터 모델
    - 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
    - E-R(Entity-Relation) 모델

3. 논리적 데이터 모델
    - 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
    - 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미
    - 관계 모델, 계층 모델, 네트워크 모델

4. 데이터 모델에 표시할 요소
    - 구조 : 논리적인 개체 타입들 간의 관계, 데이터 구조 및 정적 성질 표현
    - 연산 : 실제 데이터를 처리하는 작업에 대한 명세로 조작하는 기본 도구
    - 제약 조건 : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건


# 개체 Entity

1. 정의 및 특징

    - 독립적으로 존재하는 유형, 무형의 정보로 서로 연관된 몇 개의 속성으로 구성됨
    - DB에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
    - 독립적으로 존재하거나 그 자체로서도 구별 가능
    - 유일한 식별자에 의해 식별 가능

2. 개체 선정 방법
    - 담당자와 인터뷰
    - 장부와 전표 이용
    - 자료 흐름도 (DFD) 통해 자료 저장소 (Data Store) 이용
    - BPR (Business Process Reengineering, 업무 프로세스 재설계) 에 의해 업무를 재정의한 경우 관련 개체를 찾음

3. 개체명 지정 방법
    - 해당 업무에서 사용하는 언어
    - 약어 사용 제한
    - 단수 명사 사용
    - 유일한 개체명


# 속성 Attribute

1. 정의 및 특징
    - DB를 구성하는 가장 작은 논리적 단위
    - 파일 구조상의 데이터 항목 또는 데이터 필드
    - 개체를 구성하는 항목 및 개체의 특성 기술
    - 속성의 수를 디그리 또는 차수라고 함
    - **튜플의 수**는 카디널리티 **Cardinality**


# 관계 Relationship

1. 형태
    - 일대일
    - 일대다
        - A 원소는 B의 여러 개와 대응, B는 A 원소 한 개와 대응
    - 다대다
        - A 원소는 B의 여러 개와 대응, B도 여러 개의 A와 대응


# 식별자 Identifier

- 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자
- 모든 개체는 한 개 이상의 식별자를 반드시 가짐

1. 주 식별자
    - 개체를 대표하는 유일한 식별자
    - 하나의 개체에 한 개만 존재

2. 보조 식별자
    - 주 식별자를 대신해 개체를 식별할 수 있는 속성
    - 하나의 개체에 하나 이상 존재

3. 내부 식별자
    - 개체 내에서 스스로 만들어지는 식별자

4. 외부 식별자
    - 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용
    - 자신의 개체에서 다른 개체를 찾아가는 연결자 역할

5. 단일 식별자
    - 주 식별자가 하나의 속성으로 구성

6. 복합 식별자
    - 주 식별자가 두 개 이상의 속성으로 구성

7. 원조 식별자
    - 가공되지 않은 원래의 식별자

8. 대리 식별자
    - 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용 (**인조 식별자**)


# E-R 모델

Entity-Relationship 모델

- 개념적 데이터 모델의 가장 대표적인 것
- E-R 다이어그램으로 1:1, 1:N, N:N 등의 관계 모형을 제한 없이 나타냄

1. 피터 첸 표기법

2. 정보 공학 표기법 (크로우즈 핏)
    - | : 필수
    - O : 선택적
    - < : 다중
    - 실선 : 1개, 까마귀 발 : N개
    - 원형 : 관계가 있을수도 없을수도

3. 바커 표기법


# 관계형 데이터 모델

- 표를 이용한 DB 구조
- 기본 키와 외래 키로 데이터 간 관계 표현
- SQL, 1:1, 1:N, N:N 관계 자유롭게 표현

1. 관계형 데이터 베이스의 Relation 구조

    - 튜플, 행, 레코드
        - 속성의 모임
        - 파일 구조상 레코드와 같은 의미
        - **튜플의 수 = 카디널리티** 또는 기수, 대응수

    - 속성, 열, 필드
        - DB를 구성하는 가장 작은 논리적 단위
        - 데이터 항목 또는 데이터 필드
        - 개체의 특성 기술
        - **속성의 수 = 디그리 또는 차수**

    - 도메인
        - 하나의 속성이 가질 수 있는 타입 원자값들의 집합
        - 예를 들어 성별 속성의 도메인은 '남', '여'로 그 외의 값은 입력될 수 없음

2. 릴레이션 특징

    - 한 릴레이션에 포함된 *튜플들은 모두 다른 값*을 가짐
    - 한 릴레이션에 포함된 튜플 사이에는 *순서가 없음*
    - 릴레이션 스키마를 구성하는 어트리뷰트 간의 *순서는 중요하지 않음*
    - 어트리뷰트는 더이상 쪼갤 수 없는 원자 값으로 저장
    - 각 어트리뷰트는 식별을 위해 유일한 이름을 가짐. 그러나 도메인에는 동일한 값이 있을 수 있음.


# 키 Key

DB에서 튜플들을 서로 구분할 수 있는 기준이 되는 속성

1. **후보키 Candidate Key**
    - 릴레이션에 있는 모든 튜플에 대해 **유일성과 최소성**을 만족시켜야 함
    - 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합
    - 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재

2. 기본키 Primary Key
    - 후보키에서 선정된 주키로 중복된 값과 NULL 값을 가질 수 없음
    - 유일성과 최소성을 가지는 튜플을 식별하기 위해 반드시 필요

3. 대체키 Alternate Key
    - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보 키

4. 슈퍼키 Super Key
    - 한 릴레이션에 있는 속성들의 집합으로 구성된 키
    - 모든 튜플에 대해 유일성은 만족시키지만 **최소성은 만족X**

5. 외래키 Foreign Key
    - 다른 릴레이션의 **기본키를 참조**하는 속성 또는 속성들의 집합
    - 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간의 참조 관계 표현


# 무결성 Integrity

DB에 저장된 데이터 값과 그것이 표현하는 현실 세계의 값이 일치하는 정확성을 의미

1. 개체 무결성 Entity Integrity 실체 무결성
    - 기본키의 속성 값이 *NULL 값 X, 중복값 X*

2. 도메인 무결성
    - 각 속성의 도메인에 지정된 값 만을 가져야 함

3. 참조 무결성
    - 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일
    - 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정

4. 사용자 정의 무결성

5. 데이터 무결성 강화
    - 어플리케이션 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가
    - 데이터베이스 트리거


# 관계 대수 및 관계 해석

1. **관계 대수**

    - 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 **어떻게 유도하는가**를 기술하는 **절차적인 언어**

    - Select : 조건을 만족하는 튜플들의 부분 집합 (수평 연산)
    - Project : 속성들의 부분 집합, 중복은 제거됨 (수직 연산)
    - Join : 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션 만드는 연산
    - Division : 도메인 값과 일치하는 R릴레이션의 튜플들을 찾아내는 연산

2. 관계 해석

    - 원하는 정보가 **무엇**이라는 것만 정의하는 **비절차적 특성**
    - 튜플 관계 해석, 도메인 관계 해석
    - 관계 대수로 표현한 식은 관계 해석으로 표현할 수 있음

    - 정량자
        - 전칭 정량자 : 모든 가능한 튜플, All의 A를 뒤집은 형태
        - 존재 정량자 : 어떤 튜플 하나라도 존재, Exists의 E를 뒤집은 형태


# 정규화, 반정규화

하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
데이터베이스의 논리적 설계 단계에서 수행

1. 정규화 목적
    - 데이터 구조의 안정성 및 무결성 유지
    - 데이터베이스 내에서 표현 가능하게 만듦
    - 효과적인 검색 알고리즘 생성
    - 중복을 배제해 이상(Anomaly)의 발생 방지 및 자료 저장 공간 최소화
    - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄임

2. 이상 Anomaly 의 개념 및 종류
    - 정규화를 거치지 않아 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못하게 발생하는 곤란한 현상

    - 삽입 이상
    - 삭제 이상
    - 갱신 이상

3. 정규화의 원칙
    - 정보의 무손실
    - 분리의 원칙
    - 데이터 중복성 감소

4. **정규화 과정** (도부이결다조)

    - 제1정규형
        - 릴레이션에 속한 모든 **도메인**이 원자 값만으로 되어 있는 정규형
    - 제2정규형
        - 완전 함수적 종속을 만족하는, **부분적 함수 종속을 제거**한 정규형
    - 제3정규형
        - 이행적 함수 종속 관계를 만족하지 않는 정규형
        - A->B, B->C 일때 A->C를 만족하는 관계 (**이행규칙**)
    - BCNF
        - 모든 **결정자**가 후보키인 정규형
    - 제4정규형
        - **다치 종속**이 성립하는 경우
        - R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형
    - 제5정규형
        - 모든 **조인 종속**이 R의 후보키를 통해서만 성립되는 정규형

5. 반정규화 개념
    - 시스템 성능 향상, 개발 및 운영 편의성을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로 **의도적으로 정규화 원칙을 위배하는 행위**

6. 반정규화 방법
    - 테이블 통합
    - 테이블 분할
    - 중복 테이블 추가
        - **집계 테이블, 진행 테이블, 특정 부분만을 포함하는 테이블**
    - 중복 속성 추가


# 시스템 카탈로그

1. 의미

    - 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
    - 데이터 사전이라고도 함
    - 시스템 카탈로그에 저장된 정보를 메타 데이터 라고 함

2. 특징

    - 일반 사용자도 SQL을 이용해 내용을 검색할 수 있음
    - INSERT, DELETE, UPDATE 문으로 **카탈로그를 갱신할 수 없음**
    - DBMS가 스스로 생성하고 유지함
    - 사용자가 SQL문을 실행시켜 변화를 주면 시스템이 자동으로 갱신함
    
3. 데이터 디렉터리 (사전 관리기)

    - 데이터 사전에 수록된 데이터를 실제로 접근하는데 필요한 정보를 관리 유지하는 시스템
    - 시스템만 접근할 수 있음
    - cf) 시스템 카탈로그는 사용자와 시스템 모두 접근 가능


# 트랜잭션

데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위

한꺼번에 모두 수행되어야 할 일련의 연산들

1. 종류

    - COMMIT : 트랜잭션 처리가 정상적으로 종료되어 수행한 변경 내용을 DB에 반영하는 명령어
    - ROLLBACK : 트랜잭션 처리가 비정상으로 종료되어 DB의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산
    - SAVEPOINT (=CHECKPOINT) : 트랜잭션 내에서 ROLLBACK할 위치인 저장점을 지정하는 명령어. 여러개 지정 가능

2. 특성

    - 원자성 **Atomicity** : 트랜잭션 연산을 데이터베이스 *모두에 반영되든지 아니면 전혀 반영되지 않아야 함*

    - 일관성 Consistency : 실행을 성공적으로 완료할 시 일관성 있는 데이터베이스 상태 유지

    - 독립성 Isolation : 둘 이상 트랜잭션 동시 실행 시 한 개의 트랜잭션만 접근 가능
    
    - 영속성 Durability : 성공적으로 완료된 트랜잭션 결과는 영구적으로 반영됨

3. CRUD 매트릭스

    - C > D > U > R 우선순위
    - 테이블, 프로세스에 C,R,U,D 가 모두 없는 경우
    - 테이블에 C 또는 R이 없는 경우 (프로세스는 하나만 있어도 돌아감)


# 뷰 View

1. 개요 및 특징

    - 기본 테이블로부터 유도된 이름을 가지는 가상 테이블로 기본 테이블과 같은 형태의 구조를 사용
    - 가상 테이블이기 때문에 물리적으로 구현되어 있지 않지만 사용자에게 있는 것처럼 간주됨 -> 저장 장치 내에 *논리적으로 존재*
    - 정의된 뷰로 다른 뷰를 정의할 수 있음
    - 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제됨

2. 뷰의 장, 단점

    - 장점
        - 논리적 데이터 독립성 제공
        - 접근 제어를 통한 자동 보안 제공
        - 사용자 데이터 관리 용이

    - 단점
        - 독립적인 인덱스를 가질 수 없음
        - 뷰의 정의를 ALTER로 변경할 수 없음 -> DROP하고 새로 CREATE 해야 함
        - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신, 연산에 *제약이 따름*


# 클러스터 Cluster

1. 개요 및 특징
    - 동일한 성격의 데이터를 데이터 블록에 저장하는 물리적 저장 방법
    - 인덱스의 단점을 해결한 기법 -> 분포도가 넓을수록 유리함
    - 분포도가 넓은 테이블의 클러스터링은 저장 공간의 절약이 가능
    - 대량의 범위를 자주 조회하는 경우 적용
    - 인덱스를 사용한 처리 부담이 되는 럽은 분포도에 활용

2. 클러스터 테이블 선정
    - 수정이 빈번하지 않은 테이블
    - ORDER BY, GROUP BY, UNION이 빈번한 테이블
    - 처리 범위가 넓어 문제가 발생하는 경우 단일 테이블 클러스터링 사용
    - 조인이 많아 문제가 발생되는 경우는 다중 테이블 클러스터링 사용

3. 고려사항
    - 클러스터링 된 테이블은 조회 속도를 향상시켜주지만 입력, 수정, 삭제 시 성능이 저하됨 (부하 증가)
    - 대용량을 처리하는 트랜잭션은 전체 테이블을 스캔하는 일이 자주 발생하므로 클러스터링을 하지 않는 것이 좋음
    - 클러스터링 된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상됨


# 인덱스

데이터베이스 성능에 많은 영향을 주는 DBMS 구성 요소로 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유한다.
DB에 저장된 자료를 더욱 빠르게 조회하기 위해 별도로 구성한 순서 데이터이다.

- DB에서 테이블을 삭제하면 인덱스도 같이 삭제
- 생성 CREATE, 삭제 DROP

# 분산 데이터베이스 설계

*논리적으로는 하나의 시스템*에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산돼 있는 데이터베이스

1. 구성 요소

    - 분산 처리기 : 자체적으로 처리 능력을 가지며 지리적으로 분산되어 있는 컴퓨터 시스템
    - 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터 베이스, 해당 지역의 특성에 맞게 구성된 데이터 베이스
    - 통신 네트워크 : 분산 처리기들을 통신망으로 연결해 논리적으로 하나의 시스템처럼 작동할 수 있도록 하는 통신 네트워크

2. 구조

    - 전역, 분할, 할당, 지역 스키마

3. **목표**

    - 위치 투명성
    - 중복 투명성
    - 병행 투명성
    - 분할 투명성
    - 장애 투명성

4. 장점

    - 지역 자치성이 높음
    - 분산 제어 가능
    - 시스템 성능 향상
    - 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
    - 신뢰성 및 가용성이 높음
    - 점진적 시스템 용량 확장이 용이

5. 단점

    - DBMS가 수행할 기능이 복잡
    - 데이터베이스 설계가 어려움
    - 소프트웨어 개발 비용 증가
    - 처리 비용 증가
    - 잠재적 오류 증가 -> 보안 어려움


# 데이터베이스 보안

데이터베이스 일부분 또는 전체에 대해서 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술

1. 암호화 Encryption

    - 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정

    - 복호화 : 암호문을 원래의 평문으로 바꾸는 과정

2. 접근 통제

    - 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것
    - 접근통제 정책, 접근통제 보안모델, 접근통제 메커니즘

    - 접근통제 정책
        - 신분 기반 정책
        - 규칙 기반 정책
        - 역할 기반 정책
    - 접근통제 메커니즘
        - 접근통제 목록 Access Control List : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 목록
        - 능력 리스트 Capability List : 주체를 기준으로 주체에게 허가된 자원 및 권한을 기록한 목록
        - 보안 등급, 패스워드, 암호화


# SQL

Structured Query Language

1. 분류

- DDL (Data Define Language, 데이터 정의어)
    - 도메인, 스키마, 테이블, 뷰, 인덱스를 정의하거나 변경 또는 삭제할 때 사용하는 언어

    - CREATE : 정의
    - ALTER : 테이블에 대한 정의 변경
    - DROP : 테이블 자체를 삭제
        - *CASCADE* : 참조하는 *모든 객체 함께 제거*
        - RESTRICTED : 다른 개체가 제거할 요소를 참조중이면 제거 취소

- DML (Data Manipulation Language, 데이터 조작어)
    - 응용 프로그램이나 질의어를 통해 저장된 데이터를 실질적으로 처리하는데 사용하는 언어

    - SELECT : 검색 
        - SELECT FROM 테이블명 [WHERE 조건]
    - INSERT : 삽입
        - INSERT INTO 테이블명 VALUES 데이터
    - DELETE : 삭제
        - DELETE FROM 테이블명 [WHERE 조건]
    - UPDATE : 내용 갱신
        - UPDATE 테이블명 SET 속성명 = 데이터 [WHERE 조건]

- DCL (Data Control Language, 데이터 제어어)
    - 데이터의 **무결성, 보안, 회복, 병행수행 제어** 등을 정의하는데 사용되는 언어
    - 데이터베이스 관리자가 데이터 관리를 목적으로 사용

    - COMMIT
    - ROLLBACK
    - GRANT : 사용 권한 부여
    - REVOKE : 사용 권한 취소

2. SELECT

- WHERE절 : 검색할 조건 기술
- ORDER BY : 특정 속성을 기준으로 정렬해 검색할 때
    - 오름차순 : ASC or 생략
    - 내림차순 : **DESC**
- GROUP BY : 특정 속성을 기준으로 그룹화해 검색할 때
- HAVING : GROUP BY와 함께 사용되며 그룹에 대한 조건 지정 
    - DISTINCT : 중복 튜플 제거

3. JOIN

- 결합, 교집합 결과를 가지는 결합 방법을 의미
- 두 릴레이션으로부터 연관된 튜플들을 결합해 하나의 새로운 릴레이션 반환

- 논리적 조인
    - INNER JOIN
        - 동등 조인 : 칼럼 값이 같은 경우
        - 자연 조인 : 같은 칼럼 명을 가진 값이 같은 경우
        - 교차 조인 : 조인 조건이 없는 모든 데이터 조합 추출

    - OUTER JOIN
        - 왼쪽 외부 조인 : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터 추출
        - 오른쪽 외부 조인 : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터 추출
        - 완전 외부 조인 : 양쪽의 모든 데이터 추출

- 물리적 조인
    - 중첩 반복 조인 NESTED-LOOP JOIN : 순차적으로 상대방 ROW를 결합해 원하는 결과를 조합하는 방식
    - 정렬 합병 조인 SORT-MERGE JOIN : 연결고리 형태로 합병하는 방식
    - 해시 조인 HASH JOIN : 해싱 함수 기법을 활용하여 조인


# SQL 활용

1. 절차형 SQL

- 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
- 일반적인 프로그래밍 언어에 비해 효율이 떨어지지만, 연속적인 작업 처리 적합
- BEGIN ~ END 형식으로 작성되는 블록 구조로 기능별 모듈화 가능

2. 프로시저 Procedure

- 호출을 통해 실행되어 미리 저장해놓은 SQL 작업 수행, 처리 결과는 한 개 이상의 값 혹은 반환을 하지 않음
- 시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용됨

- DECLARE : 선언부
- BEGIN : 실행부
    - CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리됨
    - SQL : DML, DCL 이 삽입되어 데이터 관리를 위한 작업 수행
    - EXCEPTION : BEGIN ~ END 안의 구문 실행시 예외가 발생하면 이를 처리
    - TRANSACTION : 수행된 데이터 작업들을 DB에 적용할지 말지 결정하는 처리부
- END : 프로시저의 종료를 의미, BEGIN/END는 함께 다님

3. 트리거 Trigger

- 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업을 **자동 수행**
- 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용됨
- DCL 을 사용할 수 없으며 DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류 발생
- 트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향을 미치므로 트리거를 생성할 때 주의 필요

- DECLARE : 선언부
- EVENT : 트리거가 실행되는 조건 명시
- BEGIN : 실행부
    - CONTROL
    - SQL : DML문이 삽입되어 데이터 관리를 위한 작업 수행
    - EXCEPTION : BEGIN ~ END 실행시 예외 발생하면 처리
- END : 트리거의 종료 의미


# DBMS 접속 기술

1. 웹 응용 시스템 구조

- 사용자 - 웹 서버 - WAS - DBMS
- 사용자는 웹 서버에 접속해 데이터를 주고 받고, 웹 서버는 WAS에게 해당 요청을 전달함. WAS는 수신한 요청을 트랜잭션 언어로 변환한 후 DBMS에 전달해 데이터를 받으면 이 데이터를 다시 웹 서버로 전달해 사용자에게 도달

2. 정적 SQL 

    - 커서를 통한 정적 처리
    - 반복문 활용
    - 실행 속도 빠름
    - 사전 검사 가능

3. 동적 SQL
   
    - 문자열 변수에 담아 동적 처리
    - 로직을 SQL 작성 (NVL 함수 사용X)
    - 느림
    - 사전 검사 불가능


# 병행제어의 로킹 단위

- 한번에 한명만 사용할 수 있게 잠그는 Locking 단위
- 로킹의 대상이 되는 객체의 크기를 로킹 단위라고 함
- 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
- 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함

- 로킹 단위가 작으면
    - 오버헤드 증가
    - DB 공유도 증가

- 로킹 단위가 크면
    - 오버헤드 감소
    - 공유도 감소