# 개발 환경 구축

응용 소프트웨어 개발을 위해 프로젝트를 이해하고 하드웨어 및 소프트웨어 장비를 구축하는 것

1. 하드웨어 환경

    - 클라이언트와 서버로 구성됨
    - 웹 서버 : 저용량의 정적 파일들을 제공
    - 웹 어플리케이션 서버 (WAS, Web Application Server) 
        - 웹 서버와 반대
        - 동적인 컨텐츠 처리
        - Apache Tomcat, IBM WebSphere, Oracle WebLogic, JEUS
    - 데이터베이스 서버
        - DB와 이를 관리하는 DBMS 운영
        - MySQL
    - 파일 서버
        - DB에 저장하기는 비효율적이거나 서비스 제공을 목적으로 유지하는 파일들을 저장
        - AWS S3

2. 웹 서버 기능

    - HTTP/HTTPS 지원
    - 통신 기록
    - 정적 파일 관리
    - 대역폭 제한
    - 가상 호스팅
    - 인증

3. 소프트웨어 환경

시스템 소프트웨어, 개발 소프트웨어로 구성

- 요구사항 관리 도구
    - 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어
    - JIRA, Trello

- 설계/모델링 도구
    - UML을 지원

- 빌드 도구
    - 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어
    - Ant, Maven, Gradle, Jenkins

- 구현 도구
    - 개발 언어를 통해 어플리케이션의 실제 구현을 지원하는 소프트웨어
    - Eclipse, Visual Studio, Node.js

- 테스트 도구

- 형상 관리 도구
    - SVN(Subversion), GIT 


4. 개발 언어 선정 기준
    - 적정성
    - 효율성
    - 이식성
    - 친밀성
    - 범용성


# 서버 개발

웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 WAS 에 탑재하는 것

1. 서버 개발 프로그래밍 언어

    - JAVA, JS, Python, PHP, Ruby 등

2. 서버 개발 프레임워크

    - 프레임워크 : 뼈대, 골조를 의미. SW에서는 특정 기능을 수행하기 위해 필요한 클래스나 인터페이스 등을 모아둔 집합체를 말함
    - 대부분 MVC 패턴을 기반으로 개발됨

    - Spring : JAVA 기반. 전자정부 표준 프레임워크 기반 기술로 사용됨
    - Node.js : JS 기반. 비동기 입출력 처리와 이벤트 위주의 높은 처리 성능을 가지고 있어 실시간으로 입출력이 빈번한 애플리케이션에 적합
    - Django : Python 기반. 컴포넌트의 재사용
    - Codeigniter : PHP 기반. 인터페이스가 간편하며 서버 자원을 적게 사용
    - Ruby on Rails : Ruby 기반. 신속한 개발 가능

3. 서버 프로그램 구현

- 모듈 및 공통 모듈을 개발한 후 모듈들을 통합하는 방식으로 구현, 유지보수가 용이해야 함
- 모듈의 *결합도를 약하게 하고, 응집도를 강하게 하여 모듈의 크기를 작게 만들어야 함*
- 복잡도와 중복성을 줄이고 일관성 유지
- 공통 모듈은 재사용할 수 있는 모듈을 의미


4. 프레임워크 특성

- 모듈화 : 변경에 따른 영향을 최소화
- 재사용성 : 재사용 가능한 모듈 제공
- 확장성 : 다형성을 통한 인터페이스 확장 가능
- 제어의 역흐름 : 객체들의 *제어를 프레임워크가 관리*함으로써 생산성 향상


# 보안 및 API

1. 소프트웨어 보안
    - 시큐어 코딩 Secure Coding
    - 기밀성, 무결성, 가용성 유지하는 것 목표

2. API
    - 응용 프로그램 개발시 라이브러리를 이용할 수 있도록 함으로써 효율적인 소프트웨어 구현을 도와주는 인터페이스
    - Open API


# 배치 프로그램

사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것

- 이벤트성 배치 : 특정 조건을 설정해두고 조건이 충족될 때만 수행
- On-Demand 배치 : 사용자 요청 시 수행
- 정기 배치 : 일, 주, 월과 같이 정해진 기간에 정기 수행

1. 배치 스케줄러, 잡 스케줄러

    - 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구

    - 스프링 배치 : Spring 프레임워크의 특성을 그대로 가져와 스프링이 가지고 있는 다양한 기능들을 모두 사용할 수 있는 오픈 소스 프레임워크
    - 쿼츠 : Spring 프레임워크로 개발되는 응용 프로그램의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리


# 변수 Variable

컴퓨터가 명령을 처리하는 도중 발생하는 값을 저장하기 위한 공간으로 변할 수 있는 값을 의미

1. 규칙
    - 영문자, 숫자, _ 사용가능
    - 첫 글자는 숫자 올 수 없음
    - 대소문자 구분
    - 공백이나 +,-,/ 사용X
    - 예약어를 변수명으로 사용X (if,for, while)
    - 변수 선언 시 문장 끝에 세미콜론 붙여야 함


# 제어문, 반복문

1. switch문

조건에 따라 분기할 곳이 여러 곳인 경우 간단하게 처리할 수 있는 제어문
```js
switch(수식) {
    case 레이블1 : 실행할 문장 // 수식의 결과가 레이블1과 일치할 때 실행
        break; // switch문 종료
    case 레이블2 : 실행할 문장
        break;
    default : 실행할 문장 // 수식의 결과가 레이블 1~2와 일치하지 않을 때, 혹은 break 없을 때 실행
}
```

2. while문

- 조건이 참인 동안 실행할 문장을 반복 수행
- 조건이 처음부터 거짓이면 단 한번도 실행하지 않음

3. do ~ while문

- while문과 같은 동작
- but, 조건이 처음부터 거짓이어도 무조건 한 번 실행함


# 절차적 프로그래밍 언어

- 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해나가는 언어
- 절차 Procedure를 중요시 함

1. 장, 단점
    - 실행 속도가 빠름
    - 다른 위치에서 호출하여 사용 가능(이식성)
    - 모듈 구성이 용이, 구조적인 프로그래밍 가능
    - 프로그램 분석 어렵고 유지 보수나 코드 수정 어려움

2. 종류
    - C
    - Algol
    - Cobol
    - Fortran
    - Basic


# 객체지향 프로그래밍 언어

- 객체들을 조립해서 프로그램을 작성할 수 있도록 한 프로그래밍 기법

1. 장, 단점
    - 재사용과 시스템 확장 용이, 코드의 재활용성이 높음
    - 사용자와 개발자 사이의 이해를 쉽게 해주고 대형 프로그램의 작성 용이
    - 정형화된 분석 및 설계 방법이 없음
    - 실행 속도가 느림

2. 종류
    - C++
    - C#
    - JAVA
    - Delphi
    - Smalltalk

3. 구성 요소
    - 객체
        - 독립적으로 식별 가능한 이름
    - 클래스
        - 데이터를 추상화하는 단위
        - 객체의 집합
    - 인스턴스
        - 클래스에 속한 각각의 객체
        - 인스턴스화 : 클래스로부터 새로운 객체를 생성하는 것
    - 메서드
        - 클래스로부터 생성된 객체를 사용하는 방법
    
4. 특징

    - 캡슐화
    - 상속성
    - 다형성
    - 추상화
    - 정보은닉


# 스크립트 언어

- HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 것으로 기계어로 컴파일되지 않고 별도의 번역기가 소스를 분석하여 동작하게 하는 언어

1. 장,단점
    - 컴파일 없이 바로 실행하므로 결과를 바로 확인 가능
    - 개발 시간이 짧고 소스코드를 빠르게 수정할 수 있음
    - 코드를 읽고 수정해야 하므로 실행 속도가 느리고, 런타임 오류가 많이 발생

2. 종류
    - JS : 클래스X, 변수선언X
    - Python : 들여쓰기 사용하여 블록을 구분하는 문법 채용, 대화형 인터프리터 언어


# 운영체제의 개념

- 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임

1. 목적
    - 처리 능력
    - 반환 시간
    - 사용 가능도
    - 신뢰도

2. 기능
    - 자원 관리
    - 스케줄링 기능
    - 편리한 인터페이스 제공, 입출력 장치와 사용자 프로그램 제어
    - 데이터 및 자원의 공유 기능 제공
    - 시스템의 오류 검사 및 복구, 자원 보호 기능 제공
    - 입,출력에 대한 보조 기능 제공

3. 종류
    - Windows : GUI
    - UNIX : CLI
    - LINUX : CLI
    - MacOS : GUI
    - MS-DOS : CLI

4. Windows 특징
    1. GUI (Graphic User Interface) : 마우스로 아이콘이나 메뉴를 선택하여 작업 수행 -> 초보자도 쉽게 사용할 수 있도록
    2. 선점형 멀티태스킹 : 동시에 여러 개의 프로그램을 실행하면서 운영체제가 CPU 이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식 -> 시스템 다운 현상없이 더욱 안정적인 작업 가능
    3. PnP (Plug and Play) : 하드웨어를 설치했을 때 필요한 시스템 환경을 OS가 자동으로 구성해주는 기능
    4. OLE (Object Linking and Embedding) : 다른 여러 응용 프로그램에서 작성된 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 하는 기능

5. UNIX 특징
    - 소스가 공개된 개방형 시스템
    - 시분할 시스템을 위해 설계된 대화식 운영체제
    - *다중 작업 지원*
    - *다중 사용자 지원*
    - *이식성이 높으며 호환성이 높음*
    - *계층 구조 (트리 구조)*의 파일 시스템

    - 커널 Kernel
        - 프로그램과 하드웨어 간의 인터페이스 역할 담당
        - 프로세스 관리, 기억장치 관리, 파일 관리, 입,출력 관리
    
    - 쉘 Shell
        - 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
        - 시스템과 사용자 간의 인터페이스 역할
        - 파이프라인 기능 지원
        - 여러 종류의 쉘이 있음


# 기억장치 관리

한정된 주기억장치의 공간을 효율적으로 사용하기 위함

반입(Fetch), 배치 (Placement), 할당 (Allocation), 교체 (Replacement)

1. 반입

    - 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략

2. 배치 

    - 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지 결정하는 전략
    - 최초 적합 : 빈 영역 중 첫번째 분할 영역에 배치
    - 최적 적합 : 빈 영역 중 단편화를 가장 작게 남기는 분할 영역에 배치
    - 최악 적합 : 단편화를 가장 많이 남기는 분할 영역에 배치

3. 할당

    - 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할지 정함

    - 연속할당 기법 : 프로그램을 주기억장치에 연속으로 할당하는 기법
    - 분산할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 할당하는 기법. 페이징 기법, 세그먼테이션 기법

4. 페이징 기법

    - 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 주기억장치의 영역 (페이지의 프레임)에 적재시켜 실행하는 기법
    - 일정한 크기로 나눈 단위를 페이지라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임이라고 함
    - 외부 단편화는 발생하지 않으나 내부 단편화 발생
    - 페이지 맵 테이블 필요 -> 비용 증가, 처리 속도 감소

5. 세그먼테이션 기법

    - 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 기억공간을 절약하기 위해 사용
    - 논리적인 크기로 나눈 단위를 세그먼트라고 하며 고유한 이름과 크기를 가짐
    - 기억장치의 사용자 관점을 보존
    - 세그먼트맵 테이블 필요
    - 기억장치 보호키 필요
    - 내부 단편화는 발생하지 않으나 외부 단편화 발생

6. 페이지 크기

    - 페이지 크기가 작을 경우
        - 페이지 단편화 감소, 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어듬
        - 효율적인 워킹 셋 유지
        - 기억장치 효율 높아짐
        - 페이지 맵 테이블의 크기가 커지고 매핑 속도가 느려짐
        - 전체적인 입,출력 시간은 늘어남

    - 페이지 크기가 클 경우
        - 페이지 단편화 증가, 한 개의 페이지를 주기억장치로 이동하는 시간이 늘어남
        - 불필요한 내용까지도 주기억장치에 저장될 수 있음
        - 페이지 맵 테이블의 크기가 작아지고 매핑 속도가 빨라짐
        - 전체적인 입,출력 효율성이 증가

7. Locality 지역성, 구역성

프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다

- 스래싱을 방지하기 위한 워킹 셋 이론의 기반

- 시간적 구역성 : 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음
    - 루프, 스택, 서브루틴, 카운팅, 집계

- 공간적 구역성 : 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음
    - 배열, 순차적 코드

8. 워킹 셋 Working Set

- 프로세스가 일정시간 동안 자주 참조하는 페이지들의 집합
- 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정됨
- 워킹 셋은 시간에 따라 변경됨

9. 스래싱 Thrashing

- 프로세스의 처리시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
- 다중 프로그래밍의 정도가 더욱 커지면서 스래싱이 나타나고 CPU의 이용률은 급격히 감소됨

- 스래싱 현상 방지 방법
    - 다중 프로그래밍의 정도를 적정 수준으로 유지
    - 페이지 부재 빈도를 조절해 사용
    - 워킹 셋을 유지함
    - 부족한 자원을 증설하고 일부 프로세스를 중단시킴


# 프로세스 및 스케줄링

1. 프로세스
    - CPU에 의해 처리되는 실행중인 프로그램을 의미하며 작업, 태스크라고도 함
    - 프로세서 Processor -> 프로세스 Process -> 프로시저 Procedure
    - 프로시저가 활동중인것
    - 비동기적 행위를 일으키는 주체
    - 운영체제가 관리하는 실행 단위
    - 실행중인 프로그램

2. 프로세스 상태 전이 관련 용어
    - 디스패치 : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정

3. 스레드
    - 프로세스 내에서의 작업 단위로 시스템의 여러 자원을 할당받아 실행하는 단위
    - 동일 프로세스 환경에서 서로 독립적인 다중 수행 가능 -> 하나의 프로세스를 여러 개의 스레드로 생성해 병행성 증진 및 성능과 처리율 향상, 응답 시간 단축, 기억장소 낭비가 줄어들고 통신 향상

    - 단일 스레드 : 하나의 프로세스에 하나의 스레드가 존재
    - 다중 스레드 : 하나의 프로세스에 하나 이상의 스레드가 존재

4. 스케줄링

프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업

- 문맥 교환 Context Switching : 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생하는 것

5. 프로세스 스케줄링 기법

- 선점 스케줄링 : 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 선점할 수 있는 기법
    - 대화식 시분할 시스템에 사용됨
    - 많은 오버헤드 발생

- 비선점 스케줄링 : 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 선점할 수 없는 기법
    - 모든 프로세스에 대한 요구를 공정하게 처리 가능
    - 프로세스 응답 시간의 예측 용이
    - 일괄 처리 방식에 적합
    - 가뭄 현상 : 중요한 작업(짧은)이 중요하지 않은 작업 (긴)을 기다리는 경우 발생

- HRN (Highest Response-ratio Next)
    가뭄 현상을 보완하기 위한 방식으로 대기 시간이 긴 프로세스일 경우 우선순위가 높아지고 우선순위 계산식의 수치가 가장 높은 것부터 낮은 순으로 우선순위를 부여해 긴 작업과 짧은 작업 간의 지나친 불평등 해소
    - 계산식 : (대기시간 + 서비스시간) / 서비스시간


# 인터넷 및 OSI 참조모델

1. IPv6 (Internet Protocol version 6)
    - IPv4의 주소 부족 문제를 해결하기 위해 개발됨
    - 128비트의 긴 주소를 사용하고 자료 전송 속도가 빠름
    - 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결 가능
    - 네트워크 기능 확장이 용이함
    - 유니캐스트, 멀티캐스트, 애니캐스트 

2. OSI 참조모델

- 응용 계층 7
    - 사용자와 네트워크 간 응용서비스 연결
    - HTTP, DNS, FTP, TELNET

- 표현 계층 6
    - 구문 검색, 코드 변환, 암/복호화
    - JPEG, MPEG

- 세션 계층 5
    - 연결 접속(유지), 동기점(대화)
    - SSH, TLS

- 전송 계층 4
    - 종단간 신뢰성 있는 데이터 전송, 흐름제어, 오류 및 혼잡 제어
    - TCP/UDP, RTCP -> 세그먼트

- 네트워크 계층 3
    - 라우팅 제공 (단말기간 데이터 전송을 위한 최적화된 경로)
    - IP, ICMP, IGMP, ARP -> 패킷

- 데이터 링크 계층 2
    - 인접 시스템 (노드) 간 물리적 연결을 이용해 데이터 전송, 동기화, 오류 및 흐름제어, 오류 검출 및 재전송
    - HDLC, PPP, LLC, MAC -> 프레임

- 물리 계층 1
    - 매체 간의 전기적, 기능적, 절차적 기능 정의
    - RS-232C, X.21 -> 비트


# TCP/IP

- 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜

1. TCP
    - OSI 7계층의 4계층에 해당
    - 신뢰성 있는 연결형 서비스 제공
    - 순서 제어, 오류 제어, 흐름 제어 기능 제공
    - 스트림 전송 기능 제공

2. IP
    - OSI 7계층의 3계층에 해당
    - 데이터 그램을 기반으로 하는 비연결형 서비스 제공
    - 라우팅 제공
    - *헤더 체크섬만 제공* (데이터 체크섬X)

3. 전송계층(4)의 주요 프로토콜

    - TCP
        - 신뢰성 있는 연결형 서비스 제공
        - 스트림 전송 기능 제공
        - 양방향 연결형 서비스 제공
    - UDP
        - 속도가 중요시되는 네트워크에서 사용
        - 실시간 전송에 유리
        - *비연결형* 서비스 제공
        - *TCP에 비해 단순한 헤더 구조* -> 오버헤드 적음
    - RTCP (Real-Time Control Protocol)
        - 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
        - 주기적으로 제어 정보 전송
        - 다중화 제공

4. 인터넷계층(3)의 주요 프로토콜

    - IP
        - 전송할 데이터에 주소 지정, 경로 설정 기능
        - 비연결형인 데이터그램 방식 사용하여 신뢰성 보장X
    - ARP (Address Resolution Protocol)
        - 호스트의 IP주소를 네트워크 접속 장치의 물리적 주소로 바꿈
        - IP -> MAC
    - RARP (Reverse Address Resolution Protocol)
        - ARP와 반대로 물리적 주소를 IP 주소로 변환
        - MAC -> IP


# RIP 라우팅 프로토콜

- Routing Information Protocol
- 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 *IGP에 해당*
- 최적의 경로를 산출하기 위한 정보로서 거리 값(홉) 만을 고려하므로 RIP를 선택한 경로가 최적의 경로가 아닌 경우가 발생할 수 있음
- 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용
- 소규모 네트워크 환경에 적합

- IGP : 내부 게이트웨이 프로토콜.
- EGP : 외부 게이트웨이 프로토콜


# 알고리즘

1. 데커의 알고리즘
    - 프로세스가 두개일때 상호 배제를 보장하는 최초의 알고리즘
    - flag와 turn 변수를 사용하여 조정

2. 램퍼드 알고리즘
    - 프로세스 n개의 상호 배제 문제를 해결한 알고리즘
    - 프로세스에게 고유한 번호를 부여하고 번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스가 먼저 임계구역에 진입하도록 구현

3. 피터슨 알고리즘
    - 프로세스가 두개일때 상호 배제를 보장. 데커의 알고리즘과 유사하지만 상대방에게 진입 기회를 양보한다는 차이가 있고 보다 더 간단하게 구현됨

4. 세마포어
    - 공유된 자원의 데이터 혹은 임계영역 등에 따라 여러 프로세스 혹은 스레드가 접근하는 것을 막아줌