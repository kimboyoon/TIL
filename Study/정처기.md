정보처리기사 필기 시험 준비를 위한 개념을 정리하는 파일입니다.
[블로그](https://m.blog.naver.com/PostView.naver?blogId=wook2124&logNo=222102993732&navType=by)를 참고하였습니다.

# 소프트웨어 생명 주기, SDLC (Software Development Life Cycle)

1. 폭포수 모형 

    - 고전적 생명 주기 모형
    - 선형 순차적 모형
    - 단계별 정의 및 산출물이 명확
    - 개발 중간에 요구사항의 변경이 용이하지 않음
    - 타당성 검토 -> 계획 -> 요구 **분**석 -> **설**계 -> **구**현 -> **테**스트 -> **유**지보수 (분설구테유)

2. 프로토타입 모형 (원형 모형)

    - 견본품을 만들어 최종 결과물을 예측하는 모형
    - 개발 중간에 요구사항의 변경이 용이

3. 나선형 모형

    - 폭포수 모형과 프로토타입 모형의 장점에 **위험 분석 기능**을 추가한 모형
    - 점진적 개발 과정 반복으로 요구사항 추가 가능
    - 정밀하고 유지보수 과정 필요 없음
    - **계**획 및 정의 -> **위**험 분석 -> 공학적 **개**발 -> 고객 **평**가 (계위개평)

4. 애자일 모형

    - 애자일은 민첩함, 기민함을 의미
    - 변화에 유연하게 대응
    - 일정한 주기(sprint)를 반복하면서 개발과정 진행
    - 절차와 도구보다 고객과의 소통에 초점을 맞춤
    - ex) XP(eXtreme Programming), 스크럼, 칸반, 크리스탈, 린


# 스크럼 기법

- 팀원 스스로가 스크럼 팀 구성
- 개발 작업에 관한 모든 것을 스스로 해결
- 2~4주 기간의 스프린트

1. 제품 책임자 PO (Product Owner)
    - 백로그를 작성하는 주체
    - 우선순위 지정, 의견 종합

2. 스크럼 마스터 SM (Scrum Master)
    - 일일 스크럼 회의 주관

3. 개발팀 DT (Development Team)
    - PO와 SM 제외한 모든 팀원
    - 최대 인원 7~8명

4. 스크럼 개발 프로세스
    - 계획 회의 -> 스프린트 -> 일일 스크럼 -> 스크럼 검토 회의 -> 스프린트 회고


# XP 기법

eXtreme Programming

1. 핵심 가치

- 용기
- 단순성
- 의사소통
- 피드백
- 존중

2. 기본 원리

- whole team 전체 팀
- small releases 소규모 릴리즈
- test-driven development 테스트 주도개발
- continuous intergration 계속적인 통합
- collective ownership 공동 소유권
- pair programming 짝 프로그래밍
- design improvement or refactoring 디자인 개선 또는 리팩토링


# 개발 기술 환경 파악

1. 운영체제 OS (Operating System)

- 소프트웨어
- windows, UNIX, Linux, Mac OS, iOS, Android 등
- 가용성, 성능, 기술지원, 구축 비용, 주변 기기

2. 미들웨어 Middleware

- 운영체제와 응용 프로그램 사이에서 추가적인 서비스를 제공하는 소프트웨어

3. 데이터베이스 관리 시스템 DBMS (Database Management System)

- 사용자와 DB 사이에서 정보를 생성하고 DB를 관리하는 소프트웨어
- DB의 구성, 접근 방법, 유지관리에 대한 모든 책임을 짐
- JDBC(Java Database Connectivity, 자바), ODBC (Open Database Connectivity, 응용프로그램)
- Oracle, MySQL, SQLite, MongoDB, Redis 등
- 가용성, 성능, 기술 지원, 구축 비용, 상호 호환성

4. 웹 어플리케이션 서버 WAS (Web Application Server)

- 정적인 콘텐츠를 처리하는 웹 서버와 반대됨
- 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어 (=소프트웨어)
- 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
- 가용성, 성능, 기술 지원, 구축 비용

5. 오픈소스

- 소스 코드를 무료로 사용할 수 있도록 공개한 것
- 라이선스의 종류, 사용자 수, 기술의 지속 가능성


# 요구사항 정의

1. 기능 요구사항
    - 기능, 입력, 출력, 저장, 수행

2. 비기능 요구사항
    - 성능, 품질, 제약사항, 호환성, 보안

3. 요구사항 개발 프로세스
    - 도출/추출 -> 분석 -> 명세 -> 확인/검증

4. 요구사항 분석 기법
    - 요구사항 분류
    - 개념 모델링 (UML)
    - 요구사항 할당
    - 요구사항 협상
    - 정형 분석

5. 요구사항 확인 기법
    - 요구사항 검토
    - 프로토타이핑
    - 모델 검증
    - 인수 테스트 (알바, 베타)


# 개념 모델링 UML (Unified Modeling Language)

1. 구성요소
    - 사물, 관계, 다이어그램
        - 사물 : 구조, 행동, 그룹, 주해
        - 관계 : 연관, 집합, 포함, 일반화, 의존, 실체화
        - 구조적, 정적 다이어그램 : 클래스, 객체, 컴포넌트, 배치, 복합체 주고, 패키지
            - 컴포넌트 다이어그램, 배치 다이어그램은 *구현 단계*에서 사용되는 다이어그램
        - 행위, 동적 다이어그램 : 유스케이스(사용사례), 시퀀스(순차), 커뮤니케이션(협업), 상태, 활동, 상호작용 개요, 타이밍


# UI 사용자 인터페이스

1. 구분
    - CLI, Command Line Interface
        - 텍스트 형태로 이뤄진 인터페이스
    - GUI, Graphical User Interface
        - 마우스로 선택해 작업을 하는 그래픽 환경의 인터페이스
    - NUI, Natural User Interface
        - 사용자의 말이나 행동으로 기기를 조작하는 인터페이스
    - VUI, Voice User Interface
        - 사람의 음성으로 기기를 조작하는 인터페이스
    - OUI, Organic User Interface
        - 모든 사물과 사용자 간의 상호작용을 위한 인터페이스

2. UI의 기본 원칙

    - **직관성**: 누구나 쉽게 이해하고 사용
    - **유효성**: 사용자의 목적을 정확하고 완벽하게 달성
    - **학습성**: 누구나 쉽게 배우고 익힐 수 있어야 함
    - **유연성**: 요구사항을 최대한 수용

3. 웹의 3요소

    - 웹 표준 Web Standards
    - 웹 접근성 Web Accessibility
    - 웹 호환성 Cross Browsing

4. UI 설계 도구

    - 와이어프레임 : 레이아웃을 협의하거나 **공유**하기 위해 사용
    - 스토리보드 : 최종적으로 참고하는 **작업 지침서, 산출물**
    - 프로토타입 : 실제 구현된 것처럼 테스트가 가능한 **동적인 모형**
    - 목업 : 실제 화면과 유사한 **정적인 모형**
    - 유스케이스 : **사용자 측면 요구사항**을 다이어그램 형식으로 묘사

5. UI 프로토타입

    - 장점

        - 사용자를 설득하고 이해시키기 쉬움, 개발시간을 줄일 수 있음, 사전 오류 발견 가능
    
    - 단점

        - 반복적인 개선 및 보완 작업으로 인한 작업 시간 증가 및 자원 소모
        - 부분적인 프로토타이핑으로 인한 중요한 작업 생략 가능성

    - ex) 페이퍼 프로토타입, 디지털 프로토타입, HTML/CSS

6. UI 시나리오 문서 요건

    - 이해성, 완전성(최대한 상세하게), 일관성, 가독성, 수정 용이성, 추적 용이성(변경사항에 대해 쉽게 추적)

7. HCI (Human Computer Interaction or Interface) : 사람과 컴퓨터의 상호작용을 연구해서 사람이 컴퓨터를 편리하게 사용하도록 만드는 학문

UX (User Experience) : 사용자의 경험

감성공학 : 1류 - 인간의 감성, 2류 - 심리적 기능, 3류 - 공학적 및 수학적 모델, 객관적


# 품질 요구사항

1. 국제 제품 품질 표준

- ISO/IEC 9126
- ISO/IEC 12119
- ISO/IEC 14598
- ISO/IEC 25000 : SW 품질 평가 통합 모델, SQuaRE 로도 불리며 위 3개 표준을 통합
    - 품질 관리 (2500n), 품질 모델 (2501n), 품질 측정 (2502n), 품질 요구 (2503n), 품질 평가 (2504n)

2. ISO/IEC 9126

    - 기능성 Functionality
        : 요구사항을 정확하게 만족하는 기능을 제공하는가

    - 신뢰성 Realiability
        : 요구된 기능을 정확하고 일관되게 오류없이 수행하는가

    - 사용성 Usability
        : 사용자가 정확하게 이해하고 사용하는가

    - 효율성 Efficiency
        : 할당된 시간 동안 한정된 자원으로 얼마나 빨리 처리하는가

    - 유지 보수성 Maintainability
        : 환경의 변화에 소프트웨어를 쉽개 개선, 확장, 수정할 수 있는가

    - 이식성 Portability
        : 소프트웨어를 다른 환경에서도 쉽게 적용할 수 있는가


# 아키텍처 패턴

1. 레이어 패턴

- 시스템을 계층(Layer)으로 구분하여 구성하는 고전적 방법
- **OSI 참조모델**

2. 클라이언트-서버 패턴

- 하나의 서버 컴포넌트와 다수 클라이언트 컴포넌트로 구성되는 패턴
- 서로 독립적

3. 파이프-필터 패턴

- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화해 파이프를 통해 데이터를 전송하는 패턴
- 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이
- 필터 컴포넌트들을 재배치하여 다양한 파이프라인 구축 가능
- UNIX의 쉘

4. 모델-뷰-컨트롤러 패턴

- 서브시스템을 3개의 부분으로 구조화하는 패턴
- 모델 : 핵심 기능과 데이터 보관
- 뷰 : 사용자에게 정보 표시
- 컨트롤러 : 사용자로부터 받은 입력 처리
- 각 부분은 서로 영향받지 않고 개발 작업 수행
- 대화형 애플리케이션에 적합

5. 마스터-슬레이브 패턴

- 마스터 컴포넌트에서 슬레이브 컴포넌트로 분할 후, 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업 수행
- 장애 허용 시스템, 병렬 컴퓨팅 시스템

6. 브로커 패턴
- 컴포넌트와 사용자를 연결해주는 패턴
- 분산 환경 시스템

7. 피어-투-피어 패턴
- 피어를 하나의 컴포넌트로 간주하며 각 피어는 클라이언트 또는 서버가 될 수 있는 패턴
- 멀티스레딩 방식

8. 이벤트-버스 패턴
- 소스가 특정 채널에 이벤트 메시지를 발행하면, 채널을 구독한 리스너들이 메시지를 받아 이벤트를 처리하는 방식
- 이벤트 생성하는 소스, 수행하는 리스너, 통로인 채널, 채널을 관리하는 버스

9. 블랙보드 패턴
- 해결책이 명확하지 않은 문제를 처리하는데 유용
- 음성인식, 차량 식별, 신호 해석

10. 인터프리터 패턴
- 특정 언어로 작성된 코드를 해석하는 컴포넌트 설계


# 객체지향

1. 객체 Object
- 독립적으로 식별 가능한 이름
- 상태는 일반적으로 시간에 따라 변함
- 객체와 객체는 상호 연관성에 의한 관계가 형성됨
- 객체가 반응할 수 있는 메시지의 집합을 행위(연산, Method)라고 하며, 객체는 행위의 특징을 나타냄
- 객체는 일정한 기억장소를 가짐

2. 클래스 Class
- 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것
- 객체 지향 프로그램에서 **데이터를 추상화하는 단위**
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀

3. 인스턴스 Instance
- 클래스에 속한 각각의 객체
- 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 함

4. 메서드 Method
- 클래스로부터 생성된 객체를 사용하는 방법
- 전통적 시스템의 함수 또는 procedure에 해당하는 연산

5. 메시지 Message
- 객체에게 어떤 행위를 하도록 지시하기 위한 방법

6. 캡슐화 Encapsulation
- 데이터와 데이터를 처리하는 함수를 하나로 묶은 것
- 인터페이스를 제외한 세부 내용이 은폐(**정보은닉**) 되어 외부 접근이 제한됨
- 외부 모듈의 변경으로 인한 파급 효과가 적음
- 재사용 용이, 인터페이스 단순
- 결합도 down, 응집도 up

7. 상속 Inheritance
- 부모 클래스의 속성과 연산을 자식 클래스가 물려받는것

8. 다중 상속 Multiple Inheritance
- 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것

9. 다형성 Polymorphism
- 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력


# 결합도 Coupling

모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계
결합도는 낮을수록 좋다 == 독립적이다

1. 내용 결합도
- 한 모듈이 다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정할 때

2. 공통 결합도
- 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때 (전역 변수)

3. 외부 결합도
- 어떤 모듈에서 선언한 변수를 외부의 다른 모듈에서 참조할 때

4. 제어 결합도
- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도

5. 스탬프 결합도
- 모듈 간 자료구조가 전달될 때

6. 자료 결합도
- 어떤 모듈이 다른 모듈을 호출하면서 매개변수(파라미터)나 인수로 데이터를 넘겨주고, 호출 받은 모듈은 받은 데이터에 대한 처리 결과를 다시 돌려줄 때


# 응집도 Cohesion

모듈의 내부 요소들이 서로 관련되어 있는 정도
응집도는 높을수록 좋다 == 독립적인 모듈

1. 우연적 응집도
- 서로 관련 없는 요소로만 구성

2. 논리적 응집도
- 유사한 성격을 갖거나 특정 형태로 분류되는 요소들로 구성

3. 시간적 응집도
- 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성

4. 절차적 응집도
- 모듈 안의 구성 요소들이 순차적으로 수행할 경우

5. 통신적(교환적) 응집도
- 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우

6. 순차적 응집도
- 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우

7. 기능적 응집도
- 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우


# 공통 모듈

1. 정확성
2. 명확성 - 일관되게 이해되고, 한가지로 해석될 수 있도록 명확하게
3. 완전성
4. 일관성
5. 추적성
6. 재사용 규모에 따른 분류
    - 함수와 객체
    - 컴포넌트
    - 애플리케이션


# 코드

1. 순차 코드 (일련 번호 코드)

- 일정 기준에 따라 차례로 일련번호 부여

2. 블록 코드 (구분 코드)

- 공통성이 있는 것끼리 블록으로 구분하고 블록 내에서 일련번호 부여

3. 10진 코드 (도서 분류식 코드)

- 0~9까지 10진 분할하고, 다시 각각에 대해 10진 분할하는 방법을 필요한 만큼 반복
- 1000: 공학, 1100: 소프트웨어 공학, 1110: 소프트웨어 설계

4. 그룹 분류 코드

- 대분류, 중분류, 소분류 구분, 각 그룹 안에서 일련 번호 부여
- 1-01-001: 본사-총무부-인사계, 2-01-001: 지사-총무부-인사계

5. 연상 코드 (기호 코드)

- 관계있는 숫자나 문자, 기호를 이용하여 코드 부여

6. 표의 숫자 코드 (유효 숫자 코드)

- 물리적 수치를 그대로 코드에 적용
- 120-720-1500: 두깨X폭X길이

7. 합성 코드

- 2개 이상의 코드를 조합
- KE-771 : 대한항공 711기

8. 코드 부여 체계

- 이름만으로 객체의 용도와 적용 범위를 알 수 있도록 코드 부여
- 코드를 부여하기 전 각 단위 시스템의 고유한 코드와 개체를 나타내는 코드가 정의되어야 함
- PJC-COM-003 : 전체 시스템 단위의 3번째 공통 모듈


# 디자인 패턴

아키텍처 패턴(전체 시스템 구조 설계)이 디자인 패턴보다 상위 수준의 설계에 사용됨
서브시스템에 속하는 컴포넌트들과 그 관계를 설계하기 위한 참조 모델

1. 생성 패턴

- 추상 팩토리 : 서로 연관, 의존하는 객체들을 그룹으로 생성해 추상적으로 표현
- 빌더 : 객체의 생성 과정과 표현 방법 분리 -> 동일한 객체 생성에도 서로 다른 결과
- 팩토리 메소드 : 객체를 생성하기 위한 인터페이스 정의, 어떤 클래스가 인스턴스화 될 것인지는 서브클래스가 결정하도록 함 (Virtual Constructor 패턴)
- 프로토타입 : 원본 객체를 복제하는 방법
- 싱글톤 : 하나의 객체를 여러 프로세스가 동시에 참조할 수 없음

2. 구조 패턴

- 어댑터 : 호환성이 없는 클래스 인터페이스를 이용할 수 있도록 변환해주는 패턴
- 브리지 : 구현부에서 추상층을 분리하여 독립적으로 확장 및 다양성을 가지는 패턴
- 컴포지트 : 여러 객체를 가진 복합, 단일 객체를 구분 없이 다룰 때 사용
- 데코레이더 : 상속하지 않고도 객체의 기능을 동적으로 확장해주는 패턴
- 퍼싸드 : 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 플라이웨이트 : 공유해서 사용함으로써 메모리를 절약하는 패턴
- 프록시 : 접근이 어려운 객체를 연결해주는 인터페이스 역할을 수행하는 패턴


# 인터페이스 요구사항 검증

인터페이스 요구사항 검토 계획 수립 -> 검토 및 오류 수정 -> 베이스라인 설정

1. 검증 방법

- 동료 검토 : 작성자가 내용을 직접 설명
- 워크 스루 : 검토회의 전에 요구사항 명세서를 미리 배포, 짧은 검토 회의
- 인스펙션 : 작성자 제외한 다른 검토 전문가들이 확인


# 인터페이스

1. 인터페이스 식별
인터페이스 요구사항 명세서와 요구사항 목록을 기반으로 개발할 시스템과 이와 연계할 내/외부 시스템 사이의 인터페이스를 식별하고 목록을 작성하는 것

2. 인터페이스 시스템 식별
송신 시스템과 수신 시스템으로 구분하여 작성

3. 인터페이스 표준 항목
- 시스템 공통부 : 시스템 간 연동 시 필요한 공통 정보

- 거래 공통부 : 연동된 후 송/수신 되는 데이터를 처리할 때 필요한 정보


# 인터페이스 방법 명세화

1. 시스템 연계 기술
- 직접 연계 방식
    - DB 링크 : 수신 시스템에서 DB link를 생성하고 송신 시스템에서 해당 DB link를 직접 참조하는 방식 
    - 테이블명@DB link명

    - DB 연결 : 수신 시스템의 WAS에서 송신 시스템 DB로 연결하는 DB 커넥션 풀을 생성하고 연계 프로그램에서 해당 DB 커넥션 풀명을 이용